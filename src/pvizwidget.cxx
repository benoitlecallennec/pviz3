#include "pvizwidget.h"
#include "pvizsync.h"

#include <QDebug>
#include <cmath>
#include <QCloseEvent>
#include <QDateTime>

#include <vtkCamera.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCellDataToPointData.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkGlyph3D.h>
#include <vtkInteractorStyleTrackballCamera.h>
//#include <vtkInteractorStyleTrackball.h>
//#include <vtkInteractorStyleTrackballActor.h>
#include <vtkInteractorStyleSwitch.h>
#include <vtkInteractorStyleRubberBand3D.h>
#include <vtkLine.h>
#include <vtkMath.h>
#include <vtkPointData.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkPolyDataWriter.h>
#include <vtkPolyLine.h>
#include <vtkProperty.h>
#include <vtkProperty2D.h>
#include <vtkRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkSphereSource.h>
#include <vtkUnsignedCharArray.h>
#include <vtkUnsignedIntArray.h>
#include <vtkAxesActor.h>
#include <vtkTransform.h>
#include <vtkStringArray.h>
#include <vtkActorCollection.h>

#include <vtkCaptionActor2D.h>
#include <vtkTextProperty.h>
#include <vtkCallbackCommand.h>
#include <vtkProp3DCollection.h>
#include <vtkObjectFactory.h>
#include <vtkInteractorStyleRubberBandPick.h>
#include <vtkDataSetMapper.h>
#include <vtkExtractGeometry.h>
#include <vtkVertexGlyphFilter.h>
#include <vtkRendererCollection.h>
#include <vtkPlanes.h>

#include <vtkSelectionNode.h>
#include <vtkSelectionSource.h>
#include <vtkSelection.h>
#include <vtkExtractSelection.h>
#include <vtkUnstructuredGrid.h>
#include <vtkExtractSelectedPolyDataIds.h>
#include <vtkInformation.h>
#include <vtkCleanPolyData.h>
#include <vtkFollower.h>

#include <vtkPlaneSource.h>
#include <vtkStripper.h>
#include <vtkSortDataArray.h>
#include <vtkTriangleFilter.h>

#include <vtkLegendBoxActor.h>
#include <vtkCubeSource.h>
//#include <vtkQuad.h>

#include <vtkWindowToImageFilter.h>
#include <vtkPNGWriter.h>
#ifdef _WIN32 
#include <vtkAVIWriter.h>
#endif

#include <vtkLabeledDataMapper.h>
//#include <vtkHoverWidget.h>

#include <vtkTransform.h>

#include <vtkTransformFilter.h>
#include <vtkTransformCoordinateSystems.h>
#include <vtkGlyphSource2D.h>
#include <vtkGlyph2D.h>
#include <vtkPolyDataMapper2D.h>
#include "vtkAssignAttribute.h"

#include <vtkRegularPolygonSource.h>

#include "pvizExtractSelectedPolyDataIds.h"

//#include <boost/foreach.hpp>
//#include <iostream>
//#include <map>
//#include <omp.h>

#define VTK_CREATE(type, name) vtkSmartPointer<type> name = vtkSmartPointer<type>::New()
#define VTK_ASSIGN(type, name) name = vtkSmartPointer<type>::New()
#define VTK_INIT(type, name) name(vtkSmartPointer<type>::New())

#define SCALE_MAX 1000

// Reference:
// Generate maximally perceptually-distinct colors
// http://www.mathworks.com/matlabcentral/fileexchange/29702-generate-maximally-perceptually-distinct-colors
// Generated by :
// distinguishable_colors(50, {'w','k'})

float distinct[][3] = {
    {     0,         0,    1.0000},
    {1.0000,         0,         0},
    {     0,    1.0000,         0},
    {1.0000,    0.1034,    0.7241},
    {1.0000,    0.8276,         0},
    {     0,    0.5172,    0.9655},
    {     0,    0.5517,    0.2759},
    {0.6552,    0.3793,    0.2414},
    //{0.3103,         0,    0.4138},
    {     0,    1.0000,    0.9655},
    {0.2414,    0.4828,    0.5517},
    {0.9310,    0.6552,    1.0000},
    {0.8276,    1.0000,    0.5862},
    {0.7241,    0.3103,    1.0000},
    {0.8966,    0.1034,    0.3448},
    {0.5172,    0.5172,         0},
    {     0,    1.0000,    0.5862},
    {1.0000,    0.9310,    1.0000}, //{0.3793,         0,    0.1724},
    {0.9655,    0.5172,    0.0690},
    {0.7931,    1.0000,         0},
    //{0.1724,    0.2414,         0},
    {     0,    0.2069,    0.7586},
    {1.0000,    0.7931,    0.5172},
    //{     0,    0.1724,    0.3793},
    {0.6207,    0.4483,    0.5517},
    {0.3103,    0.7241,    0.0690},
    {0.6207,    0.7586,    1.0000},
    {0.5862,    0.6207,    0.4828},
    {1.0000,    0.4828,    0.6897},
    {0.6207,    0.0345,         0},
    {1.0000,    0.7241,    0.7241},
    {0.5172,    0.3793,    0.7931},
    {0.6207,         0,    0.4483},
    {0.5172,    0.8621,    0.6552},
    {1.0000,         0,    0.9655},
    {     0,    0.8276,    1.0000},
    {1.0000,    0.4483,    0.3448},
    {0.3448,    0.2414,    0.2069},
    {0.8275,    0.8275,    0.8275}, //{     0,    0.2414,    0.2069},
    {0.8621,    0.3793,    0.8621},
    {0.3793,    0.4483,    0.6897},
    {0.7241,    0.7931,    0.1724},
    //{0.0690,    0.6897,    0.6552},
    //{0.3793,    0.0690,         0},
    {0.3294,    0.3294,    0.3294}, //{0.1724,         0,    0.1724},
    {0.3448,         0,    0.7931},
    {0.5862,    0.7586,    0.7931},
    {0.8276,    0.6207,    0.1379},
    {0.5172,    0.6897,    0.3448},
    {0.8966,    0.9310,    0.7241},
    {0.9655,    0.8276,    1.0000},
    //{0.7241,    0.3103,    0.3793}
    {0.5517,    0.0345,    0.6552},
    {0.4138,    0.3103,         0},
    {     0,    0.2414,    0.6207},
    {0.4828,    0.2414,    0.4828}
};
/*
float distinctb[][3] = {
    {     0,    1.0000,         0},
    {     0,         0,    1.0000},
    {1.0000,         0,         0},
    {     0,    0.9655,    1.0000},
    {1.0000,    0.4828,    0.8621},
    {1.0000,    0.8621,    0.4828},
    {     0,    0.5517,    1.0000},
    {     0,    0.4138,    0.0345},
    {0.6207,    0.2759,    0.2069},
    {0.2414,         0,    0.4138},
    {1.0000,    0.9310,    1.0000},
    {0.5517,    1.0000,    0.6207},
    {0.8966,         0,    1.0000},
    {0.3103,    0.4828,    0.5517},
    {0.8621,    1.0000,         0},
    {1.0000,         0,    0.4138},
    {0.9310,    0.5172,         0},
    {0.4828,    0.3448,    0.9655},
    {0.5517,         0,    0.3448},
    {0.4828,    0.4138,         0},
    {0.6207,    0.7241,    0.5517},
    {0.5517,    0.4138,    0.6897},
    {0.3793,    0.7241,         0},
    {1.0000,    0.6207,    0.6897},
    {     0,    0.1724,    0.3793},
    {0.2414,    0.7586,    1.0000},
    {0.2414,    0.3103,    0.1724},
    {0.6552,    0.0345,    0.6552},
    {0.3793,    0.2414,    0.3103},
    {     0,    0.7241,    0.5517},
    {1.0000,    0.8276,         0},
    {1.0000,    0.4138,    0.3103},
    {     0,         0,    0.6207},
    {0.2759,         0,         0},
    {0.9310,    0.7241,    1.0000},
    {0.7931,    0.5862,    0.4138},
    {1.0000,         0,    0.6552},
    {0.8621,    1.0000,    0.4828},
    {0.1724,    0.2759,    0.6897},
    {0.6207,    0.6552,         0},
    {0.5862,    0.8276,    0.8621},
    {0.6897,    0.5862,    0.6552},
    {0.7931,    0.5172,    1.0000},
    {     0,    1.0000,    0.4483},
    {0.6552,         0,         0},
    {0.5172,         0,    0.8966},
    {0.1724,         0,    0.1724},
    {1.0000,    1.0000,    0.7931},
    {0.8966,    0.3103,    0.5517},
    {0.6897,    1.0000,    0.8276}    
};
*/

#define RGB_F(r, g, b) {r/255.0, g/255.0, b/255.0}

float colorbrewer_set1[][3] = {
    RGB_F(228,  26,  28),
    RGB_F( 55, 126, 184),
    RGB_F( 77, 175,  74),
    RGB_F(152,  78, 163),
    RGB_F(255, 127,   0),
    RGB_F(255, 255,  51),
    RGB_F(166,  84,  40),
    RGB_F(247, 129, 191),
    RGB_F(153, 153, 153)
};

float colorbrewer_paired[][3] = {
    RGB_F(166, 206, 227),
    RGB_F( 31, 120, 180),
    RGB_F(178, 223, 138),
    RGB_F( 51, 160,  44),
    RGB_F(251, 154, 153),
    RGB_F(227,  26,  28),
    RGB_F(253, 191, 111),
    RGB_F(255, 127,   0),
    RGB_F(202, 178, 214),
    RGB_F(106,  61, 154),
    RGB_F(255, 255, 153),
    RGB_F(177,  89,  40)
};

float salsa17[][3] = {
    RGB_F(  0,    0, 255),
    RGB_F(255,  170, 255),
    RGB_F(170,   85,   0),
    RGB_F(170,   85, 255),
    RGB_F(  0,  255, 219),
    RGB_F(255,  255, 127),
    RGB_F(119,  136, 153),
    RGB_F( 85,  170, 127),
    RGB_F( 73,  255,   0),
    RGB_F( 85,    0,   0),
    RGB_F(219,  255,   0),
    RGB_F(255,  219,   0),
    RGB_F(255,  146,   0),
    RGB_F(170,  255, 255),
    RGB_F(255,    0,   0),
    RGB_F(192,  192, 192),
    RGB_F(255,  255, 255)
};

double black[3]       = { 0.0, 0.0, 0.0 };
double white[3]       = { 1.0, 1.0, 1.0 };
double red[3]         = { 1.0, 0.3, 0.3 };
double red_pure[3]    = { 1.0, 0.0, 0.0 };
double green[3]       = { 0.3, 1.0, 0.3 };
double green_pure[3]  = { 0.0, 1.0, 0.0 };
double blue[3]        = { 0.3, 0.3, 1.0 };
double blue_pure[3]   = { 0.0, 0.0, 1.0 };
double yellow[3]      = { 1.0, 1.0, 0.3 };
double yellow_pure[3] = { 1.0, 1.0, 0.0 };
double magenta[3]     = { 1.0, 0.3, 1.0 };
double cyan[3]        = { 0.3, 1.0, 1.0 };
double orange[3]      = { 1.0, 0.5, 0.0 };
double violet[3]      = { 2.0 / 3.0, 0.0, 1.0 };

QColor PvizToQColor(PvizColor pvizcol)
{
    return QColor((QRgb)pvizcol.ui_color);
}

QColor PvizToQColor(PvizColor* pvizcol)
{
    return QColor((QRgb)(pvizcol->ui_color));
}

PvizColor QColorToPviz(QColor qcol)
{
    return PvizColor((unsigned int)qcol.rgba());
}

//
/*
3. Serialization format
We will use the following format:
STEPID | TYPE | LENGTH | DATA ...
where
STEPID (integer) : Step id, starting from 0
TYPE (integer) : Type of data. 0 (ClassID), 1 (XYZ Position)
LENGTH (integer) : Length of data
Data :
If type == 0, N class ID. I.e, C_1 | C_2 | ... C_N where C_n is integer
If type == 1, N XYZ positions. I.e., X_1 | Y_1 | Z_1 | X_2 | Y_2 | Z_2 | X_3 | .... | Z_N, where numbers are double
 */

void FindAllData(vtkPolyData* polydata)
{
    std::cout << "Normals: " << polydata->GetPointData()->GetNormals() << std::endl;
    
    vtkIdType numberOfPointArrays = polydata->GetPointData()->GetNumberOfArrays();
    std::cout << "Number of PointData arrays: " << numberOfPointArrays << std::endl;
    
    vtkIdType numberOfCellArrays = polydata->GetCellData()->GetNumberOfArrays();
    std::cout << "Number of CellData arrays: " << numberOfCellArrays << std::endl;
    
    std::cout << "Type table/key: " << std::endl;;
    //more values can be found in <VTK_DIR>/Common/vtkSetGet.h
    std::cout << VTK_UNSIGNED_CHAR << " unsigned char" << std::endl;
    std::cout << VTK_UNSIGNED_INT << " unsigned int" << std::endl;
    std::cout << VTK_FLOAT << " float" << std::endl;
    std::cout << VTK_DOUBLE << " double" << std::endl;
    
    for(vtkIdType i = 0; i < numberOfPointArrays; i++)
    {
        // The following two lines are equivalent
        //arrayNames.push_back(polydata->GetPointData()->GetArray(i)->GetName());
        //arrayNames.push_back(polydata->GetPointData()->GetArrayName(i));
        //int dataTypeID = polydata->GetPointData()->GetArray(i)->GetDataType();
        //std::cout << "Array " << i << ": " << polydata->GetPointData()->GetArrayName(i)
        //<< " (type: " << dataTypeID << ")" << std::endl;
        std::cout << "Array " << i << ": " << polydata->GetPointData()->GetArrayName(i) << std::endl;
    }
    
    for(vtkIdType i = 0; i < numberOfCellArrays; i++)
    {
        // The following two lines are equivalent
        //polydata->GetPointData()->GetArray(i)->GetName();
        //polydata->GetPointData()->GetArrayName(i);
        //int dataTypeID = polydata->GetCellData()->GetArray(i)->GetDataType();
        //std::cout << "Array " << i << ": " << polydata->GetCellData()->GetArrayName(i)
        //<< " (type: " << dataTypeID << ")" << std::endl;
        std::cout << "Array " << i << ": " << polydata->GetCellData()->GetArrayName(i) << std::endl;
    }
}

PvizWidget::PvizWidget(QWidget* p, Qt::WFlags f)
: QVTKWidget(p, f), 
axesVisible(true), 
cubeAxesVisible(false),
plotVisible(true),
lineVisible(true),
glyphVisible(false), 
glyphAutoOrientation(false), 
fpsVisible(false),
labelVisible(false),
plotLineWidth(2),
plotPointSize(2),
glyphScaleFactor(1.0),
legendVisible(false),
legendHeightFactor(0.3),
legendWidthFactor(0.3),
colorbarVisible(false),
colorbarNumberOfLabels(5),
playTimerDuration_(50),
hoverTimerDuration_(500), 
colorMap_(CUSTOM), 
visibleMode_(FULL), 
interactorMode_(INTERACT_MODE),
useSyncCamera(false),
sync_(NULL), 
axesActor(vtkSmartPointer<vtkActor>::New()),
glyph(vtkSmartPointer<vtkGlyph3D>::New()),
//glyphActor(vtkSmartPointer<vtkActor>::New()),
//glyphActor(vtkSmartPointer<vtkLODActor>::New()),
glyphActor(vtkSmartPointer<vtkQuadricLODActor>::New()),
legendActor(vtkSmartPointer<vtkLegendBoxActor>::New()),
interactorStyle(vtkSmartPointer<pvizInteractorStyle>::New()),
//interactorStyle(vtkSmartPointer<vtkInteractorStyleRubberBand2D>::New()),
cbFPS(vtkSmartPointer<vtkCallbackCommand>::New()),
cbGlyph(vtkSmartPointer<vtkCallbackCommand>::New()),
cbPickCenter(vtkSmartPointer<vtkCallbackCommand>::New()),
localCamera(vtkSmartPointer<vtkCamera>::New()),
savedPoints(vtkSmartPointer<vtkPoints>::New()),
areaPicker(vtkSmartPointer<vtkAreaPicker>::New()),
cellPicker(vtkSmartPointer<vtkCellPicker>::New()),
pointPicker(vtkSmartPointer<vtkPointPicker>::New()),
//propPicker(vtkSmartPointer<vtkPropPicker>::New()),
gs00(vtkSmartPointer<vtkRegularPolygonSource>::New()),
gs01(vtkSmartPointer<vtkRegularPolygonSource>::New()),
gs02(vtkSmartPointer<vtkRegularPolygonSource>::New()),
gs03(vtkSmartPointer<vtkRegularPolygonSource>::New()),
gs10(vtkSmartPointer<vtkConeSource>::New()),
gs11(vtkSmartPointer<vtkCubeSource>::New()),
gs12(vtkSmartPointer<vtkSphereSource>::New()),
gs13(vtkSmartPointer<vtkCylinderSource>::New()),

cf(vtkSmartPointer<vtkColorTransferFunction>::New()),
savedPointsExist(false),
labelActor(vtkSmartPointer<vtkActor2D>::New()),
//hoverLabelActor(vtkSmartPointer<vtkActor2D>::New()),
titleActor(vtkSmartPointer<vtkTextActor>::New()),
//cubeAxesActor(vtkSmartPointer<vtkCubeAxes2Actor>::New()),
cubeAxesActor(vtkSmartPointer<vtkCubeAxesActor>::New()),
colorbarActor(vtkSmartPointer<vtkScalarBarActor>::New()),
//scaleAxesActor(vtkSmartPointer<pvizAxesActor>::New()),
numOfNeighbors_(15),
appendNeighbors(false),
selectedNeighbors(vtkSmartPointer<vtkIdList>::New()),
defaultColor(QColor(119, 136, 153)), // slate gray
defaultScale(0.0),
legendPosition(UPPERLEFT),
#ifdef USE_ACTIVEMQ
connection(NULL),
session(NULL),
sendTopic(NULL),
listenTopic(NULL),
consumer(NULL),
producer(NULL),
isFirstLabelMessage(true),
isFirstPositionMessage(true),
#endif
modelStatus(0),
focusMode_(AUTO)
{
    this->setFocusPolicy(Qt::WheelFocus);
    
    connect(this, SIGNAL(OnModelCreated()), this, SLOT(loadModel()));
    connect(this, SIGNAL(OnModelUpdated()), this, SLOT(updateModel()));
    
	// See VTK/Depth Peeling
	this->GetRenderWindow()->SetAlphaBitPlanes(1);
	this->GetRenderWindow()->SetMultiSamples(0);
	
	renderer = vtkSmartPointer<vtkRenderer>::New();
	//backgroundColor_ = QColor(51,51,51); // Gray
	backgroundColor_ = QColor(0,0,0); // Gray
	renderer->SetBackground(backgroundColor_.redF(), backgroundColor_.greenF(), backgroundColor_.blueF());
	renderer->SetUseDepthPeeling(1);
	//renderer->SetMaximumNumberOfPeels(4);
	//renderer->SetMaximumNumberOfPeels(100);
	//renderer->SetOcclusionRatio(0.1);
	//renderer->SetOcclusionRatio(0.2);
	
	//renderer->SetBackground(51/255.0, 51/255.0, 51/255.0); // Gray
	//renderer->SetBackground(255/255.0, 255/255.0, 255/255.0); // White
	this->GetRenderWindow()->AddRenderer(renderer);

	vtkRenderWindowInteractor* interactor = this->GetInteractor();  
	interactor->SetInteractorStyle(interactorStyle);

    pointPicker->SetTolerance(0.01); // Default : 0.025
    
	interactor->SetPicker(cellPicker);
	
	// Initialize must be called prior to creating timer events.
    interactor->Initialize();
    
	// Sign up to receive TimerEvent
	VTK_CREATE(vtkCallbackCommand, cb1);
	cb1->SetCallback(PvizWidget::InteractorTimerEvent);
	cb1->SetClientData(this);
	interactor->AddObserver(vtkCommand::TimerEvent, cb1);
		
    VTK_CREATE(vtkCallbackCommand, cb2);
	cb2->SetCallback(PvizWidget::AreaPickerCallBack);
	cb2->SetClientData(this);
	areaPicker->AddObserver(vtkCommand::EndPickEvent, cb2);
	
    VTK_CREATE(vtkCallbackCommand, cb3);
	cb3->SetCallback(PvizWidget::ResetCameraClippingRangeEventCallBack);
	cb3->SetClientData(this);
	renderer->AddObserver(vtkCommand::ResetCameraClippingRangeEvent, cb3);
	renderer->AddObserver(vtkCommand::RenderEvent, cb3);
	renderer->AddObserver(vtkCommand::EndEvent, cb3);
	//areaPicker->AddObserver ( vtkCommand::EndPickEvent, pickCallback );
	
    VTK_CREATE(vtkCallbackCommand, cb4);
	cb4->SetCallback(PvizWidget::PickerCallBack);
	cb4->SetClientData(this);
    cellPicker->AddObserver(vtkCommand::EndPickEvent, cb4);
	pointPicker->AddObserver(vtkCommand::EndPickEvent, cb4);
	//propPicker->AddObserver(vtkCommand::EndPickEvent, cb4);
    cellPicker->PickFromListOn();
    pointPicker->PickFromListOn();
    areaPicker->PickFromListOn();
    //propPicker->PickFromListOn();
	
	VTK_CREATE(vtkAxesActor, axesActor);
	//axesActor->AxisLabelsOn();
	axesActor->SetShaftTypeToLine();
	//axesActor->SetTipTypeToCone();
	axesActor->GetXAxisCaptionActor2D()->GetCaptionTextProperty()->ShadowOff();
	axesActor->GetYAxisCaptionActor2D()->GetCaptionTextProperty()->ShadowOff();
	axesActor->GetZAxisCaptionActor2D()->GetCaptionTextProperty()->ShadowOff();
	
	VTK_ASSIGN(vtkOrientationMarkerWidget, orientationMarker);
	//widget->SetOutlineColor( 0.9300, 0.5700, 0.1300 );
	orientationMarker->SetOrientationMarker( axesActor );
	orientationMarker->SetInteractor( this->GetRenderWindow()->GetInteractor() );
	//widget->SetInteractor( this->GetInteractor() );
	orientationMarker->SetViewport( 0.0, 0.0, 0.2, 0.2 );
	orientationMarker->SetEnabled( 1 );

    // Disabled due to OpenGL Error report on VTK 6.1
    // Ref: http://www.vtk.org/Wiki/VTK/OpenGL_Errors
    //orientationMarker->InteractiveOff();
	
	//this->update();
	//this->GetRenderWindow()->Render();
	
	model = new PvizModel();
	
	BuildCornerAnnotation();
	
	cbFPS->SetCallback(PvizWidget::RendererEndCallBack);
	cbFPS->SetClientData(this);

	cbGlyph->SetCallback(PvizWidget::RendererEndCallBack);
	cbGlyph->SetClientData(this);
    
	cbPickCenter->SetCallback(PvizWidget::PickCenterCallBack);
	cbPickCenter->SetClientData(this);

    // Default is invisible
    labelActor->SetVisibility(false);
    //hoverLabelActor->SetVisibility(false);
}

PvizWidget::~PvizWidget() throw()
{
    qDebug() << "PvizWidget ... destroying";
    
    if (model != NULL) delete model;
#ifdef USE_ACTIVEMQ
    //*************************************************
    // Always close destination, consumers and producers before
    // you destroy their sessions and connection.
    //*************************************************
    
    // Destroy resources.
    try
    {
        if( sendTopic != NULL ) 
            delete sendTopic;
    }
    catch (CMSException& e) {}
    sendTopic = NULL;
    
    try
    {
        if( listenTopic != NULL ) 
            delete listenTopic;
    }
    catch (CMSException& e) {}
    listenTopic = NULL;
    
    try
    {
        if( consumer != NULL ) 
            delete consumer;
    }
    catch (CMSException& e) {}
    consumer = NULL;
    
    // Close open resources.
    try
    {
        if( session != NULL ) 
            session->close();
        
        if( connection != NULL ) 
            connection->close();
    }
    catch (CMSException& e) {}
    
    // Now Destroy them
    try
    {
        if( session != NULL ) 
            delete session;
    }
    catch (CMSException& e) {}
    session = NULL;
    
    try{
        if( connection != NULL ) 
            delete connection;
    }
    catch (CMSException& e) {}
    connection = NULL;
#endif
}

int PvizWidget::SaveAsVTK(QString filename)
{
	VTK_CREATE(vtkPolyDataWriter, pdw);
	//pdw->SetInput(c2p->GetPolyDataOutput());
#if VTK_MAJOR_VERSION <= 5
	pdw->SetInput(plot);
#else
    pdw->SetInputData(plot);
#endif
	pdw->SetFileName(filename.toAscii().data());
	pdw->Write();
	
	return SUCCESS;
}

void PvizWidget::SaveToModel()
{
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
    
	foreach(PvizCluster* cluster, clusters_)
	{
		double rgba[4];
        
        if (cluster->IsDefault()) 
        {
            switch(colorMap_)
            {
                case CUSTOM:
                    rgba[0] = cluster->GetColor()->uc_color.r/255.0;
                    rgba[1] = cluster->GetColor()->uc_color.g/255.0;
                    rgba[2] = cluster->GetColor()->uc_color.b/255.0;
                    break;
                case RAINBOW:
                case RAINBOW_R:
                case COOL2WARM:
                case COOL2WARM_R:
                case JET:
                case JET_R:
                case HSV:
                case HOT:
                case EXPERIMENTAL:
                    cf->GetColor(cluster->id, rgba);
                    break;
                case COLORBREW_SET1:
                {
                    int ncolor = sizeof(colorbrewer_set1) / sizeof(colorbrewer_set1[0]);
                    rgba[0] = (double) colorbrewer_set1[cluster->id % ncolor][0];
                    rgba[1] = (double) colorbrewer_set1[cluster->id % ncolor][1];
                    rgba[2] = (double) colorbrewer_set1[cluster->id % ncolor][2];
                }
                    break;
                case COLORBREW_PAIRED:
                {
                    int ncolor = sizeof(colorbrewer_paired) / sizeof(colorbrewer_paired[0]);
                    rgba[0] = (double) colorbrewer_paired[cluster->id % ncolor][0];
                    rgba[1] = (double) colorbrewer_paired[cluster->id % ncolor][1];
                    rgba[2] = (double) colorbrewer_paired[cluster->id % ncolor][2];
                }
                    break;
                case MATLAB_DISTINCT:
                {
                    int ncolor = sizeof(distinct) / sizeof(distinct[0]);
                    rgba[0] = (double) distinct[cluster->id % ncolor][0];
                    rgba[1] = (double) distinct[cluster->id % ncolor][1];
                    rgba[2] = (double) distinct[cluster->id % ncolor][2];
                }
                    break;
                case SALSA_CUSTOM:
                {
                    int ncolor = sizeof(salsa17) / sizeof(salsa17[0]);
                    rgba[0] = (double) salsa17[cluster->id % ncolor][0];
                    rgba[1] = (double) salsa17[cluster->id % ncolor][1];
                    rgba[2] = (double) salsa17[cluster->id % ncolor][2];
                }
                    break;
                default:
                    break;
                
            }
            rgba[3] = 1.0;
        }
        else
        {
            vtkIdType idx = lut->GetIndex(cluster->id);
            lut->GetTableValue(idx, rgba);
        }
		
		cluster->GetColor()->setRgbF(rgba[0], rgba[1], rgba[2], rgba[3]);
	}
    
	vtkUnsignedIntArray *pids = vtkUnsignedIntArray::SafeDownCast(plot->GetPointData()->GetArray(POINT_ID_NAME));
	vtkPoints *points = plot->GetPoints();
    
	QMap<unsigned int, PvizPoint*> points_(model->points);
 	foreach(PvizPoint* point, points_)
	{
		vtkIdType pidx = pids->LookupValue(point->id);		
		points->GetPoint(pidx, point->position);
	}
	
    model->title = std::string(titleActor->GetInput());
    model->pointsize = plotPointSize;
    model->glyphvisible = glyphVisible;
    model->glyphscale = glyphScaleFactor;
    model->focusmode = (unsigned int) focusMode_;
    model->focus[0] = focus[0];
    model->focus[1] = focus[1];
    model->focus[2] = focus[2];
}

int PvizWidget::SaveAsXML(QString filename)
{
    SaveToModel();
	
	model->saveXmlDataFile(filename.toAscii().data());	
	
	return SUCCESS;
}

int PvizWidget::SaveAsTXT(QString filename)
{
    SaveToModel();
	
	model->saveSimpleDataFile(filename.toAscii().data());	
	
	return SUCCESS;
}

void PvizWidget::LoadCompressedDataFile(QString filename)
{
    fileName_ = filename;
	model->loadCompressedDataFile(filename.toAscii().data());
	loadModel();
}

void PvizWidget::LoadXmlDataFile(QString filename)
{
    fileName_ = filename;
	model->loadXmlDataFile(filename.toAscii().data());	
	loadModel();
}

void PvizWidget::LoadSimpleDataFile(QString filename)
{
    fileName_ = filename;
	model->loadSimpleDataFile(filename.toAscii().data());	
	loadModel();
}

void PvizWidget::ReloadSimpleDataFile(QString filename)
{
    PvizModel* model_ = new PvizModel();
    try
    {
        model_->loadSimpleDataFile(filename.toAscii().data());
    }
    catch (int e)
    {
        qDebug() << "Error" << e;
        delete model_;
        return;
    }
    
    qDebug() << model_->toString().c_str();
    
	QMap<unsigned int, PvizPoint*> points_(model_->points);
	foreach(PvizPoint* point, points_)
	{
        unsigned int pid = point->id;
        model->points[pid]->position[0] = point->position[0];
        model->points[pid]->position[1] = point->position[1];
        model->points[pid]->position[2] = point->position[2];
        model->points[pid]->label = point->label;
    }
    
    //QMap<unsigned int, PvizCluster*> clusters_(model_->clusters);
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model_->clusterList);
	foreach(PvizCluster* cluster, clusters_)
    {
        unsigned int cid = cluster->id;
        model->clusters[cid]->visible = cluster->visible;
        model->clusters[cid]->SetScale(cluster->GetScale());
        model->clusters[cid]->SetColor(*(cluster->GetColor()));
    }

    delete model_;
    
    updateModel();
}

void PvizWidget::LoadHDF5DataFile(QString filename)
{
    fileName_ = filename;
#ifdef PVIZMODEL_USE_HDF5
	model->loadHDF5DataFile(filename.toAscii().data(), "M.dat");
	loadModel();
#else
	qDebug() << "HDF5 is disabled";
#endif
}

void PvizWidget::loadModel()
{
	qDebug() << model->toString().c_str();
	
    plotPointSize = model->pointsize;
    plotLineWidth = model->linewidth;
    glyphVisible = model->glyphvisible;
    glyphScaleFactor = model->glyphscale;
    focusMode_ = (FocusMode_t) model->focusmode;
    focus[0] = model->focus[0];
    focus[1] = model->focus[1];
    focus[2] = model->focus[2];
    
	// Convert std::map to QMap to use foreach statement
	QMap<unsigned int, PvizPoint*> points_(model->points);
	//QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
	QMap<unsigned int, PvizLine*> lines_(model->lines);
	//QMap<unsigned int, PvizPoint*> gridPoints_(model->gridPoints);
	
	VTK_CREATE(vtkPoints, points);
	VTK_CREATE(vtkUnsignedIntArray, pids);
	
	pids->SetName(POINT_ID_NAME);
	pids->SetNumberOfValues(points_.size());
	
	foreach(PvizPoint* point, points_)
	{
		vtkIdType pid = points->InsertNextPoint(point->position);
		pids->SetValue(pid, point->id);
	}
	
	VTK_CREATE(vtkCellArray, polys);
	VTK_CREATE(vtkUnsignedIntArray, cids);
	VTK_CREATE(vtkFloatArray, cellScales);
	VTK_CREATE(vtkUnsignedIntArray, pointcids);
	VTK_CREATE(vtkFloatArray, pointScales);
	VTK_CREATE(vtkStringArray, pointLabels);
	VTK_CREATE(vtkUnsignedIntArray, pointShapes);
	
	cids->SetName(CELL_ID_NAME);
	cids->SetNumberOfValues(clusters_.size());
	cellScales->SetName(CLUSTER_SCALE_NAME);
	cellScales->SetNumberOfValues(clusters_.size());
	pointcids->SetName(CLUSTER_ID_NAME);
	pointcids->SetNumberOfValues(points_.size());
	pointScales->SetName(POINT_SCALE_NAME);
	pointScales->SetNumberOfValues(points_.size());
	pointLabels->SetName(POINT_LABEL_NAME);
	pointLabels->SetNumberOfValues(points_.size());
	pointShapes->SetName(SHAPE_ID_NAME);
	pointShapes->SetNumberOfValues(points_.size());
	
	foreach(PvizCluster* cluster, clusters_)
	{
		vtkIdType cidx = polys->InsertNextCell(cluster->points.size());
		cids->SetValue(cidx, cluster->id);
        
		cellScales->SetValue(cidx, cluster->GetScale());
		
		foreach(PvizPoint* point, cluster->points)
		{
			vtkIdType pidx = pids->LookupValue(point->id);
			polys->InsertCellPoint(pidx);
            // Testing...
			pointcids->SetValue(pidx, cluster->id);
			//pointcids->SetValue(pidx, cidx);
			pointScales->SetValue(pidx, cluster->IsDefault() ? defaultScale : cluster->GetScale());
			// Make sure to use c_str() to work in Windows
            //QString("[%1:%2]").arg(point->id, cluster->id).toStdString().append(point->label).c_str();
			pointLabels->SetValue(pidx, point->label.c_str());
			QString label = QString("[%1:%2] %3").arg(point->id).arg(cluster->id).arg(point->label.c_str());
			//pointLabels->SetValue(pidx, QString("[%1:%2] ").arg(point->id).arg(cluster->id).toStdString().append(point->label).c_str());
			pointLabels->SetValue(pidx, label.toAscii());
            pointShapes->SetValue(pidx, cluster->shape);
		}
	}
	
	double cidsRange[2];
	cids->GetRange(cidsRange);
	
	//vtkSmartPointer<vtkPolyData> plot;
	//plot = vtkSmartPointer<vtkPolyData>::New();
	VTK_ASSIGN(vtkPolyData, plot);
	
	plot->SetPoints(points);
	plot->SetVerts(polys);
	//plot->SetLines(lines);

	plot->GetPointData()->AddArray(pids);
	plot->GetPointData()->AddArray(pointcids);
	plot->GetPointData()->AddArray(pointScales);
	plot->GetPointData()->AddArray(pointLabels);
	plot->GetPointData()->AddArray(pointShapes);
	plot->GetPointData()->SetActiveScalars(CLUSTER_ID_NAME);
	
	// Doesn't work with lines ...
	// Number of cells mismatch error.
	//plot->GetCellData()->AddArray(cids);
	//plot->GetCellData()->AddArray(cellScales);
	
	plot->GetFieldData()->AddArray(cids);
	
	// Build color table
	//vtkSmartPointer<vtkLookupTable> lut = vtkSmartPointer<vtkLookupTable>::New();
	//lut = vtkSmartPointer<vtkLookupTable>::New();
	//VTK_CREATE(vtkLookupTable, lut);
	VTK_ASSIGN(vtkLookupTable, lut);
	//lut->SetNumberOfTableValues(clusters_.size());
    
    // Note
    // Colors are colored with respect to CID values
    // LookUpTable should have same number of entries of the ranges of CID
	lut->SetNumberOfTableValues((int)(cidsRange[1] - cidsRange[0] + 1));
	lut->SetTableRange(cidsRange);
    
    // Option 2 : Colored by cidx
	//lut->SetNumberOfTableValues(clusters_.size());
	//lut->SetTableRange(0, clusters_.size() - 1);
    
    /*
    for (int cid = (int) cidsRange[0]; cid < (int) cidsRange[1]; cid++)
    {
        vtkIdType idx = lut->GetIndex(cid);
        qDebug() << cid << idx;
    }
	*/
    
    //double range[2];
    //range[0] = 0;
    //range[1] = (double)(clusters_.size() -1);
	//lut->SetTableRange(range[0], range[1]);
    
	lut->Build();
        
	SetColorMap(colorMap_);
	
	BuildSubplot();
	
	UpdateLines();
	
	BuildPlot();
	
	BuildLabels();
	//BuildHoverLabels();
	
	//vtkSmartPointer<vtkFollower> follower = vtkSmartPointer<vtkFollower>::New();
	//follower->SetMapper(labelMapper);
	
	//renderer->AddActor(follower);
	
	//------------------------------
	// Glyph
	// See http://www.vtk.org/Wiki/VTK/FAQ#How_to_handle_large_data_sets_in_VTK to improve performance
	//------------------------------	
	BuildGlyph();
	
	//------------------------------
	// Grid
	//------------------------------
	BuildGrid();
	
	//------------------------------
	// Axes
	//------------------------------
	BuildAxes();

	//------------------------------
	// Render
	//------------------------------
	BuildLegend();
	
	BuildHoverWidget();	
	BuildCornerAnnotation();
	
	//------------------------------
	// Title
	//------------------------------
    titleActor->SetInput ( model->title.c_str() );
    titleActor->SetTextScaleModeToViewport();
    //titleActor->SetTextScaleModeToProp();
    titleActor->GetPositionCoordinate()->SetCoordinateSystemToNormalizedViewport();
    titleActor->GetPosition2Coordinate()->SetCoordinateSystemToNormalizedViewport();
    titleActor->SetPosition ( 0.01, 0.99 );
    titleActor->SetPosition2 ( 0.99, 0.99 );

    titleActor->GetTextProperty()->SetColor ( 1.0, 0.0, 0.0 );
    titleActor->GetTextProperty()->SetJustificationToCentered();    
    titleActor->GetTextProperty()->SetFontSize ( 12 );

    titleActor->UseBorderAlignOn();
    if (GetTitle() == "")
        titleActor->SetVisibility(false);
    
    renderer->AddActor2D ( titleActor );
    
    colorbarActor->SetLookupTable(lut);
    colorbarActor->SetLabelFormat("%g");
    colorbarActor->SetWidth(0.08);
    colorbarActor->SetPosition(0.9, 0.1);
    colorbarActor->SetVisibility(colorbarVisible);
    renderer->AddActor2D ( colorbarActor );
    
    //------------------------------
	// Render
	//------------------------------
	//renderer->ResetCamera();
	//renderer->Render();
	//this->GetRenderWindow()->Render();
    
    emit OnModelLoaded(this);
    
    qDebug() << "load ... Done.";
}

void PvizWidget::BuildSubplot()
{
	//QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
	vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);

	// list of cells to be selected
	VTK_ASSIGN(vtkIdTypeArray, selectedCellIds);
	foreach(PvizCluster* cluster, clusters_)
	{
		if (cluster->visible) 
		{
			vtkIdType cidx = cids->LookupValue(cluster->id);
			selectedCellIds->InsertNextValue(cidx);
		}
	}
	
	VTK_CREATE(vtkSelectionNode, selectCell);
	selectCell->SetFieldType(vtkSelectionNode::CELL);
	selectCell->SetContentType(vtkSelectionNode::INDICES);
	selectCell->SetSelectionList(selectedCellIds);
	
	// Inverse doesn't work
	//selectCell->SetSelectionList(unselectedCellIds);
	//selectCell->GetProperties()->Set(vtkSelectionNode::INVERSE(), 1);
	
	VTK_CREATE(vtkSelection, sel);
	sel->AddNode(selectCell);
	
	/*
	 VTK_CREATE(vtkExtractSelection, ex);
	 ex->SetInput(0, plot);
	 ex->SetInput(1, sel);
	 ex->PreserveTopologyOn(); 
	 ex->Update();
	 //vtkUnstructuredGrid* extracted = ex->GetOutput();
	 */
	
	//VTK_CREATE(vtkExtractSelectedPolyDataIds, ex);
	VTK_CREATE(pvizExtractSelectedPolyDataIds, ex);
	//vtkExtractSelectedPolyDataIds* subplot = vtkExtractSelectedPolyDataIds::New();
#if VTK_MAJOR_VERSION <= 5
	ex->SetInput(0, plot);
	ex->SetInput(1, sel);
#else
    ex->SetInputData(0, plot);
    ex->SetInputData(1, sel);
#endif
	//ex->PreserveTopologyOn();
	//ex->PRESERVES_TOPOLOGY();
	//selFilter->SetInputConnection(0,plot->GetProducerPort());
	ex->Update();
	
	//VTK_CREATE(vtkCleanPolyData, cleansubplot);
	VTK_ASSIGN(vtkCleanPolyData, cleansubplot);
	cleansubplot->SetInputConnection(ex->GetOutputPort());
	cleansubplot->PointMergingOff();
	cleansubplot->ConvertLinesToPointsOff();
	cleansubplot->ConvertPolysToLinesOff();
	cleansubplot->ConvertStripsToPolysOff();
	cleansubplot->Update();    
}

void PvizWidget::BuildPlot()
{
	vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);
	
	double cidsRange[2];
	cids->GetRange(cidsRange);
    
	//VTK_CREATE(vtkPolyDataMapper, plotMapper);
	VTK_CREATE(vtkPolyDataMapper, plotMapper);
#if VTK_MAJOR_VERSION <= 5
	plotMapper->SetInput(cleansubplot->GetOutput());
#else
    plotMapper->SetInputConnection(cleansubplot->GetOutputPort());
#endif
	plotMapper->ScalarVisibilityOn();
	//plotMapper->SetScalarModeToUseCellFieldData();
	//plotMapper->SelectColorArray(CLUSTER_ID_NAME);
	plotMapper->SetColorModeToMapScalars();
	plotMapper->SelectColorArray(CLUSTER_ID_NAME);
	//plotMapper->SetScalarRange(pointcids->GetRange());
	plotMapper->SetScalarRange(cidsRange);
	plotMapper->SetLookupTable(lut);
	
	
	//VTK_CREATE(vtkLODActor, plotActor);
	VTK_ASSIGN(vtkActor, plotActor);
	plotActor->SetMapper(plotMapper);
	plotActor->GetProperty()->SetPointSize(plotPointSize);
	plotActor->GetProperty()->SetLineWidth(plotLineWidth);
	plotActor->SetVisibility(plotVisible);
	
	renderer->AddActor(plotActor);
    pointPicker->AddPickList(plotActor);
    areaPicker->AddPickList(plotActor);
    //propPicker->AddPickList(plotActor);
	qDebug() << "plotActor added ... done.";
	
}

void PvizWidget::BuildLabels()
{
	VTK_ASSIGN(vtkIdTypeArray, selectedPointIds);
	
	VTK_CREATE(vtkSelectionNode, selectPoint);
	selectPoint->SetFieldType(vtkSelectionNode::POINT);
	selectPoint->SetContentType(vtkSelectionNode::INDICES);	
	selectPoint->SetSelectionList(selectedPointIds);
	
	VTK_CREATE(vtkSelection, sel2);
	sel2->AddNode(selectPoint);
	
	VTK_CREATE(vtkExtractSelection, ex2);
	
#if VTK_MAJOR_VERSION <= 5
	ex2->SetInput(0, plot);
	ex2->SetInput(1, sel2);
#else
    ex2->SetInputData(0, plot);
    ex2->SetInputData(1, sel2);
#endif
	ex2->Update();
	
	VTK_CREATE(vtkLabeledDataMapper, labelMapper);
#if VTK_MAJOR_VERSION <= 5
	labelMapper->SetInput(ex2->GetOutput());
#else
    labelMapper->SetInputConnection(ex2->GetOutputPort());
#endif
	labelMapper->SetLabelModeToLabelFieldData();
	labelMapper->SetFieldDataName(POINT_LABEL_NAME);
	//labelMapper->GetLabelTextProperty()->ShadowOff();
	//labelMapper->GetLabelTextProperty()->SetColor(0.0, 1.0, 0.0);
    // Not working
	//labelMapper->GetLabelTextProperty()->SetOrientation(-60.0);
    
	
	//VTK_CREATE(vtkActor2D, labelActor);
	labelActor->SetMapper(labelMapper);
	
	renderer->AddActor(labelActor);
}

void PvizWidget::BuildGlyph()
{
	QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
    //QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
	vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);
	
	// list of cells to be selected
	VTK_ASSIGN(vtkIdTypeArray, selectedCellIdsForGlyph);
	foreach(PvizCluster* cluster, clusters_)
	{
		if ((cluster->visible) && (cluster->GetScale() != 0.0))
		{
			vtkIdType cidx = cids->LookupValue(cluster->id);
			selectedCellIdsForGlyph->InsertNextValue(cidx);
		}
	}
	
	VTK_CREATE(vtkSelectionNode, selectCellForGlyph);
	selectCellForGlyph->SetFieldType(vtkSelectionNode::CELL);
	selectCellForGlyph->SetContentType(vtkSelectionNode::INDICES);	
	selectCellForGlyph->SetSelectionList(selectedCellIdsForGlyph);
	
	VTK_CREATE(vtkSelection, sel);
	sel->AddNode(selectCellForGlyph);
	//sel->RemoveNode(selectCellForGlyph);
	
    VTK_CREATE(pvizExtractSelectedPolyDataIds, ex);
    //VTK_CREATE(vtkExtractSelectedPolyDataIds, ex);
    //VTK_CREATE(vtkExtractSelectedIds, ex);
#if VTK_MAJOR_VERSION <= 5
    ex->SetInput(0, plot);
    ex->SetInput(1, sel);
#else
    ex->SetInputData(0, plot);
    ex->SetInputData(1, sel);
#endif
	//ex->PreserveTopologyOn();
	//ex->PRESERVES_TOPOLOGY();
	//selFilter->SetInputConnection(0,plot->GetProducerPort());
	ex->Update();
    // Don't use ReleaseDataFlagOn(). Picking will not work.
    //FindAllData(plot);
	
	//VTK_CREATE(vtkCleanPolyData, cleansubplotForGlyph);
	VTK_ASSIGN(vtkCleanPolyData, cleansubplotForGlyph);
    cleansubplotForGlyph->SetInputConnection(ex->GetOutputPort());
    //cleansubplotForGlyph->SetInputData(plot);
	cleansubplotForGlyph->PointMergingOff();
	cleansubplotForGlyph->ConvertLinesToPointsOff();
	cleansubplotForGlyph->ConvertPolysToLinesOff();
	cleansubplotForGlyph->ConvertStripsToPolysOff();
	cleansubplotForGlyph->Update();
	
	//points->GetData()->GetRange(range);
	double len = 1E+37; // or use DBL_MAX
    for (int i = 0; i < 3; i++)
    {
        double range[2];
        plot->GetPoints()->GetData()->GetRange(range, i);
        double len_ = range[1] - range[0];
        if ((len_ != 0.0) && (len_ < len))
        {
            len = len_;
        }
    }

	//VTK_ASSIGN(vtkGlyph3D, glyph);
	//VTK_CREATE(vtkSphereSource, sphere);
	//VTK_CREATE(vtkRegularPolygonSource, sphere);
	double r = len/(double)SCALE_MAX;
    
    // vtkRegularPolygonSource (NumberOfSides : 3)
    gs00->SetNumberOfSides(3);
    gs00->SetRadius(r);
    //gs00->ReleaseDataFlagOn();
    
    // vtkRegularPolygonSource (NumberOfSides : 4)
    gs01->SetNumberOfSides(4);
    gs01->SetRadius(r);
    //gs01->ReleaseDataFlagOn();
    
    // vtkRegularPolygonSource (NumberOfSides : 5)
    gs02->SetNumberOfSides(5);
    gs02->SetRadius(r);
    //gs02->ReleaseDataFlagOn();
    
    // vtkRegularPolygonSource (NumberOfSides : 6)
    gs03->SetNumberOfSides(6);
    gs03->SetRadius(r);
    //gs03->ReleaseDataFlagOn();

    // vtkConeSource
    gs10->SetResolution(3);
    gs10->SetHeight(r);
    gs10->SetRadius(r);
    //gs10->ReleaseDataFlagOn();
    
    // vtkCubeSource
    gs11->SetXLength(r);
    gs11->SetYLength(r);
    gs11->SetZLength(r);
    //gs11->ReleaseDataFlagOn();
    
    // vtkSphereSource
    gs12->SetRadius(r);
    //gs12->ReleaseDataFlagOn();
    
    // vtkCylinderSource
    gs13->SetHeight(r);
    gs13->SetRadius(r);
    //gs13->ReleaseDataFlagOn();
    
#if VTK_MAJOR_VERSION <= 5
    glyph->SetInput(cleansubplotForGlyph->GetOutput());
#else
    //glyph->SetInputData(plot);
    //glyph->SetInputData(ex->GetOutput());
    glyph->SetInputData(cleansubplotForGlyph->GetOutput());
#endif
    
	glyph->SetSourceConnection(0, gs00->GetOutputPort());
	glyph->SetSourceConnection(1, gs01->GetOutputPort());
	glyph->SetSourceConnection(2, gs02->GetOutputPort());
	glyph->SetSourceConnection(3, gs03->GetOutputPort());
	glyph->SetSourceConnection(4, gs10->GetOutputPort());
	glyph->SetSourceConnection(5, gs11->GetOutputPort());
	glyph->SetSourceConnection(6, gs12->GetOutputPort());
	glyph->SetSourceConnection(7, gs13->GetOutputPort());
    
	glyph->SetScaleModeToScaleByScalar();
	glyph->SetColorModeToColorByScalar();
	glyph->SetScaleFactor(glyphScaleFactor);
    glyph->SetVectorModeToUseVector();
	
    //glyph->SetIndexModeToScalar();
    glyph->SetIndexModeToVector();
    glyph->SetRange(0, 7);
    glyph->OrientOff();
    glyph->GeneratePointIdsOn();
    
	//glyph->SetInputArrayToProcess(0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, CLUSTER_SCALE_NAME);
	glyph->SetInputArrayToProcess(0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, POINT_SCALE_NAME);
	glyph->SetInputArrayToProcess(1, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, SHAPE_ID_NAME);
	//glyph->SetInputArrayToProcess(3, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, CLUSTER_ID_NAME);
	//glyph->SetInputArrayToProcess(1, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, CLUSTER_ID_NAME);
    glyph->Update();
	
	VTK_CREATE(vtkPolyDataMapper, glyphMapper);
#if VTK_MAJOR_VERSION <= 5
	glyphMapper->SetInput(glyph->GetOutput());
#else
    glyphMapper->SetInputConnection(glyph->GetOutputPort());
#endif
    
	// Color by cluster id
	glyphMapper->SetColorModeToMapScalars();
	glyphMapper->SelectColorArray(CLUSTER_ID_NAME);
	// Use cluster ranges in cells, not in points
	glyphMapper->SetScalarRange(plot->GetFieldData()->GetArray(CELL_ID_NAME)->GetRange());
	glyphMapper->SetLookupTable(lut);
	//glyphMapper->GlobalImmediateModeRenderingOn();
	
	//VTK_ASSIGN(vtkActor, glyphActor);
	//VTK_ASSIGN(vtkLODActor, glyphActor);
	glyphActor->SetMapper(glyphMapper);
	glyphActor->SetVisibility(glyphVisible);
    glyphActor->GetProperty()->SetInterpolationToFlat();
	//qDebug() << "SetNumberOfCloudPoints: " << glyphActor->GetNumberOfCloudPoints();

	renderer->AddActor(glyphActor);	
    cellPicker->AddPickList(glyphActor);
    pointPicker->AddPickList(glyphActor);
    areaPicker->AddPickList(glyphActor);
	qDebug() << "glyphActor added ... done.";
    
    //SetGlyphVisible(TRUE);
    SetGlyphVisible(glyphVisible);
    
    /*
    // 2D Glyph
    // Error : Cannot make color right
    VTK_CREATE(vtkTransformCoordinateSystems, xform);
    xform->SetInput(cleansubplotForGlyph->GetOutput());
    xform->SetInputCoordinateSystemToWorld();
    xform->SetOutputCoordinateSystemToDisplay();
    xform->SetViewport(renderer);
    xform->Update();
    
    VTK_CREATE(vtkGlyphSource2D, gs);
    gs->SetGlyphTypeToCircle();
    gs->SetScale(20);
    gs->FilledOff();
    gs->CrossOn();
    
    xform->GetOutput()->GetPointData()->AddArray(<#vtkAbstractArray *array#>)
    VTK_CREATE(vtkGlyph2D, glypher);
    glypher->SetInput(xform->GetOutput());
    glypher->SetSource(gs->GetOutput());
	glypher->SetScaleModeToScaleByScalar();
	glypher->SetColorModeToColorByScalar();
	glypher->SetColorModeToColorByScale();
	glypher->SetInputArrayToProcess(0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, POINT_SCALE_NAME);
    
    VTK_CREATE(vtkPolyDataMapper2D, mapper);
    mapper->SetInput(glypher->GetOutput());
    //mapper->SetColorModeToDefault();
	mapper->SetColorModeToMapScalars();
	//mapper->SetScalarModeToUsePointData();
    mapper->ColorByArrayComponent(CLUSTER_ID_NAME, -1);
	mapper->SetScalarRange(plot->GetFieldData()->GetArray(CELL_ID_NAME)->GetRange());
	mapper->SetLookupTable(lut);

    
    VTK_CREATE(vtkActor2D, glyph2DActor);
    glyph2DActor->SetMapper(mapper);
    
	renderer->AddActor(glyph2DActor);	
     */
}

void PvizWidget::BuildGrid()
{
	QMap<unsigned int, PvizPoint*> gridPoints_(model->gridPoints);
	
	VTK_CREATE(vtkPoints, gridPoints);
	VTK_CREATE(vtkCellArray, gridPolys);
	
	gridPolys->InsertNextCell(model->gridPoints.size());
	foreach(PvizPoint* gridpoint, gridPoints_)
	{
		vtkIdType pidx = gridPoints->InsertNextPoint(gridpoint->position);
		gridPolys->InsertCellPoint(pidx);
	}
	
	VTK_CREATE(vtkPolyData, grid);
	grid->SetPoints(gridPoints);
	grid->SetVerts(gridPolys);
	
	VTK_CREATE(vtkPolyDataMapper, gridMapper);
#if VTK_MAJOR_VERSION <= 5
	gridMapper->SetInput(grid);
#else
    gridMapper->SetInputData(grid);
#endif
	
	VTK_CREATE(vtkActor, gridActor);
	gridActor->SetMapper(gridMapper);
	gridActor->GetProperty()->SetPointSize(2);
	gridActor->GetProperty()->SetColor(0.9608, 0.8706, 0.7020); //Wheat
	//plotActor->VisibilityOff();
	
	renderer->AddActor(gridActor);  
	qDebug() << "gridActor added ... done.";
}

void PvizWidget::BuildAxes()
{
	double range[2];
	plot->GetPoints()->GetData()->GetRange(range);
	//points->GetData()->GetRange(range);
	double len = range[1] - range[0];
	
	double m = len/2.0;
	
	double x0[3] = {m, 0.0, 0.0};
	double x1[3] = {-m, 0.0, 0.0};
	double y0[3] = {0.0, m, 0.0};
	double y1[3] = {0.0, -m, 0.0};
	double z0[3] = {0.0, 0.0, m};
	double z1[3] = {0.0, 0.0, -m};
	
	// Create a vtkPoints object and store the points in it
	VTK_CREATE(vtkPoints, pts);
	pts->InsertNextPoint(x0);
	pts->InsertNextPoint(x1);
	pts->InsertNextPoint(y0);
	pts->InsertNextPoint(y1);
	pts->InsertNextPoint(z0);
	pts->InsertNextPoint(z1);
	
	// Setup two colors - one for each line
	unsigned char red[3] = {255, 0, 0};
	//unsigned char yellow[3] = {255, 255, 0};
	unsigned char green[3] = {0, 255, 0};
	unsigned char blue[3] = {0, 0, 255};
	
	// Setup the colors array
	VTK_CREATE(vtkUnsignedCharArray, colors);
	colors->SetNumberOfComponents(3);
	colors->SetName("Colors");
	
	// Add the colors we created to the colors array
	colors->InsertNextTupleValue(red);
	//colors->InsertNextTupleValue(yellow);
	colors->InsertNextTupleValue(green);
	colors->InsertNextTupleValue(blue);
	
	// Create the first line (between Origin and P0)
	VTK_CREATE(vtkLine, line0);
	line0->GetPointIds()->SetId(0,0); //the second 0 is the index of the Origin in the vtkPoints
	line0->GetPointIds()->SetId(1,1); //the second 1 is the index of P0 in the vtkPoints
	
	// Create the second line (between Origin and P1)
	VTK_CREATE(vtkLine, line1);
	line1->GetPointIds()->SetId(0,2); //the second 0 is the index of the Origin in the vtkPoints
	line1->GetPointIds()->SetId(1,3); //2 is the index of P1 in the vtkPoints
	
	VTK_CREATE(vtkLine, line2);
	line2->GetPointIds()->SetId(0,4); //the second 0 is the index of the Origin in the vtkPoints
	line2->GetPointIds()->SetId(1,5); //2 is the index of P1 in the vtkPoints
	
	
	// Create a cell array to store the lines in and add the lines to it
	VTK_CREATE(vtkCellArray, axesLines);
	axesLines->InsertNextCell(line0);
	axesLines->InsertNextCell(line1);
	axesLines->InsertNextCell(line2);
	
	// Create a polydata to store everything in
	VTK_CREATE(vtkPolyData, linesPolyData);
	
	// Add the points to the dataset
	linesPolyData->SetPoints(pts);
	
	// Add the lines to the dataset
	linesPolyData->SetLines(axesLines);
	
	// Color the lines - associate the first component (red) of the
	// colors array with the first component of the cell array (line 0)
	// and the second component (green) of the colors array with the
	// second component of the cell array (line 1)
	linesPolyData->GetCellData()->SetScalars(colors);
	// Visualize
	VTK_CREATE(vtkPolyDataMapper, axesMapper);
#if VTK_MAJOR_VERSION <= 5
	axesMapper->SetInput(linesPolyData);
#else
    axesMapper->SetInputData(linesPolyData);
#endif
	
	//renderer->ResetCamera();
	ResetCamera();
	
	

	//VTK_CREATE(vtkTransform, transform);
	//transform->Scale(0.5, 0.5, 0.5);
	//transform->Translate(center);
	
	//VTK_ASSIGN(vtkActor, axesActor);
	//vtkSmartPointer<vtkActor> axesActor = vtkSmartPointer<vtkActor>::New();
	//axesActor = vtkSmartPointer<vtkActor>::New();
	axesActor->SetMapper(axesMapper);
	//axesActor->SetOrigin(center);
	axesActor->SetScale(0.5, 0.5, 0.5);
	axesActor->SetVisibility(axesVisible);
	//axesActor->SetUserTransform(transform);
    //axesActor->SetPosition(center);
	
	renderer->AddActor(axesActor);	
    
    cubeAxesActor->SetBounds(cleansubplot->GetOutput()->GetBounds());
    cubeAxesActor->SetCamera(renderer->GetActiveCamera());
    cubeAxesActor->SetVisibility(cubeAxesVisible);
    cubeAxesActor->SetXTitle("");
    cubeAxesActor->SetYTitle("");
    cubeAxesActor->SetZTitle("");
    cubeAxesActor->SetFlyModeToOuterEdges();
    renderer->AddActor(cubeAxesActor);
    
    
    /*
    // Create the axis actor
    vtkSmartPointer<vtkAxisActor> axis = vtkSmartPointer<vtkAxisActor>::New();
    axis->SetAxisTypeToX();
    qDebug() << "GetAxisType()" << axis->GetAxisType();
    axis->SetPoint1(-1,0,0);
    axis->SetPoint2(1,0,0);
    axis->SetBounds(-1,1,-1,1,-1,1);
    axis->SetRange(-1,1);
    axis->SetTickLocationToBoth();
    
    axis->SetDeltaMinor(0.5);
    axis->SetMinorTickSize(0.04);
    axis->SetMinorStart(-1);
    //axis->MinorTicksVisibleOff();
    
    axis->SetDeltaMajor(0.1);
    axis->SetMajorTickSize(0.02);
    axis->SetMajorStart(-1);
    
    vtkSmartPointer<vtkStringArray> labels = vtkSmartPointer<vtkStringArray>::New();
    labels->SetNumberOfTuples(11);
    labels->SetValue(0,"0");
    labels->SetValue(1,"1");
    labels->SetValue(2,"2");
    labels->SetValue(5,"5");
    labels->SetValue(10,"10");
    axis->SetLabels(labels);
    axis->LabelVisibilityOn();
    axis->SetLabelScale(0.04);
    
    axis->SetTitle("X Axis");
    axis->SetTitleScale(0.04);
    
    axis->DrawGridlinesOn();
    
    //axis->SetCamera(renderer->GetActiveCamera());
    //renderer->AddActor(axis);        
    
    double* bounds = cleansubplot->GetOutput()->GetBounds();
    xAxisActor->SetAxisTypeToX();
    xAxisActor->SetAxisRange(bounds[0], bounds[1]);
    xAxisActor->SetCamera(renderer->GetActiveCamera());
    renderer->AddActor(xAxisActor);
    */
    
    //scaleAxesActor->SetBounds(cleansubplot->GetOutput()->GetBounds());
    //scaleAxesActor->SetCamera(renderer->GetActiveCamera());
    //renderer->AddActor(scaleAxesActor);
}

void PvizWidget::BuildHoverWidget()
{
	vtkRenderWindowInteractor* interactor = this->GetInteractor();  
	//interactor->DestroyTimer(hoverTimer_);
	//hoverTimer_ = interactor->CreateRepeatingTimer(hoverTimerDuration_);
	
	vtkSmartPointer<vtkCallbackCommand> cb = vtkSmartPointer<vtkCallbackCommand>::New();
	cb->SetCallback(PvizWidget::HoverCallBack);
	cb->SetClientData(this);
	//interactor->AddObserver(vtkCommand::TimerEvent, cb);
	interactor->AddObserver(vtkCommand::LeftButtonPressEvent, cb);
	interactor->AddObserver(vtkCommand::MiddleButtonPressEvent, cb);
	interactor->AddObserver(vtkCommand::RightButtonPressEvent, cb);
	interactor->AddObserver(vtkCommand::MouseWheelForwardEvent, cb);
	interactor->AddObserver(vtkCommand::MouseWheelBackwardEvent, cb);
	interactor->AddObserver(vtkCommand::MouseMoveEvent, cb);
	interactor->AddObserver(vtkCommand::KeyPressEvent, cb);	
    
    // Testing ...
	interactor->AddObserver(vtkCommand::EndInteractionEvent, cb);
}

void PvizWidget::BuildCornerAnnotation()
{
	//vtkSmartPointer<vtkCornerAnnotation> cornerAnnotation = vtkSmartPointer<vtkCornerAnnotation>::New();
	//VTK_CREATE(vtkCornerAnnotation, cornerAnnotation);
	VTK_ASSIGN(vtkCornerAnnotation, cornerAnnotation);
	cornerAnnotation->SetLinearFontScaleFactor( 2 );
	cornerAnnotation->SetNonlinearFontScaleFactor( 1 );
	cornerAnnotation->SetMaximumFontSize( 14 );
	//cornerAnnotation->SetText( 0, "lower left" );
	//cornerAnnotation->SetText( 1, "lower right" );
	//cornerAnnotation->SetText( 2, "upper left" );
	//cornerAnnotation->SetText( 3, "upper right" );
	cornerAnnotation->GetTextProperty()->SetColor(1.0,0.0,0.0);
	cornerAnnotation->SetVisibility(fpsVisible);
	
	renderer->AddViewProp(cornerAnnotation);
}

void PvizWidget::ConnectToServer()
{
#ifdef PVIZRPC_CLIENT_ENABLE
	model->connectPvizRPCServer("127.0.0.1", 12345);
	model->loadFromPvizRPCServer();
	outstandingRequest_ = false;
	
	loadModel();
#else
	qDebug() << "PvizRPC client disabled.";
#endif
}

void PvizWidget::UpdateFromServer()
{
	qDebug() << "UpdateFromServer ... ";
	
#ifdef PVIZRPC_CLIENT_ENABLE
	if (!outstandingRequest_) 
	{
		outstandingRequest_ = true;
		model->updateFromPvizRPCServer();
		updateModel();
		
		//boost::asio::deadline_timer t(io_service_, boost::posix_time::seconds(5));
		//t.async_wait(boost::bind(&MainWindow::UpdateFromServer, this));
		//io_service_.run_one();
	}	
#else
	qDebug() << "PvizRPC client disabled.";
#endif
}

void PvizWidget::ConnectToActiveMQServer(QString brokerURI,
                                         QString destURI,
                                         QString listenURI)
{
#ifdef USE_ACTIVEMQ
    connection = NULL;
    session = NULL;
    consumer = NULL;
    //useTopic = useTopic;
    //this->brokerURI = brokerURI;
    //this->destURI = destURI;
    //this->listenURI = listenURI;
    //clientAck = clientAck;
    
    try 
    {
		qDebug() << "ConnectToActiveMQServer ... " << brokerURI;
		
        // Create a ConnectionFactory
        ActiveMQConnectionFactory* connectionFactory = new ActiveMQConnectionFactory( std::string(brokerURI.toAscii().constData()) );
		//new ActiveMQConnectionFactory( "tcp://156.56.104.176:61616?wireFormat.maxInactivityDuration=0" );
		qDebug() << " connectionFactory ... created.";
		
        // Create a Connection
        connection = connectionFactory->createConnection();
        delete connectionFactory;
		qDebug() << " connection ... created.";
        
        ActiveMQConnection* amqConnection = dynamic_cast<ActiveMQConnection*>( connection );
        if( amqConnection != NULL ) 
        {
            amqConnection->addTransportListener( this );
        }
        
        connection->start();
        
        connection->setExceptionListener(this);
        
        // Create a Session
        session = connection->createSession( Session::AUTO_ACKNOWLEDGE );
        
        // Listen first ..
        // Create a MessageConsumer from the Session to the Topic or Queue
        listenTopic = session->createTopic( std::string(listenURI.toAscii().constData()) );
        //listenTopic = session->createTopic( destURI.toStdString() );
        consumer = session->createConsumer( listenTopic );
        consumer->setMessageListener( this );
        
        
        // Sending ..
        sendTopic = session->createTopic( std::string(destURI.toAscii().constData()) );
        
        // Create a MessageProducer from the Session to the Topic or Queue
        producer = session->createProducer( sendTopic );
        producer->setDeliveryMode( DeliveryMode::NON_PERSISTENT );

        cgl::pviz::rpc::PvizMessage pvizmessage;
        pvizmessage.set_type(cgl::pviz::rpc::PvizMessage::SYNC);
        
        qint64 msec = QDateTime::currentMSecsSinceEpoch();
        pvizmessage.set_timestamp((::google::protobuf::int64)msec);
        pvizmessage.set_stepid(0);
        
        std::string text;
        pvizmessage.SerializeToString(&text);
        //qDebug() << pvizmessage.DebugString() ;
        qDebug() << "serialized text size :" << text.length();
        
        BytesMessage* message = session->createBytesMessage();
        //message->writeString(text);
        //message->writeBytes((unsigned char *) text.c_str(), 0, text.length());
        //qDebug() << "getBodyLength :" << message->getBodyLength() ;
        
        message->writeInt(-1); // Label (0), Position (1), SYN (-1), FIN (-2)
        timestamp = msec;
        message->writeLong(timestamp);
        message->writeInt(0); // Iteration
        
        producer->send( message );
        delete message;    
                
    } 
	catch (CMSException& e) {
		qDebug() << "CMSException : " << e.getMessage().size();
        e.printStackTrace();
    }
    catch (exception& e) {
		qDebug() << "Exception : " << e.what();
    }
#endif
}

#ifdef USE_ACTIVEMQ
void PvizWidget::onMessage( const Message* message ) throw() 
{
    static int count = 0;
    static std::vector<int> labels;
    static std::vector<Point3D> positions;
    //static bool isFirstLabelMessage = true;
    //static bool isFirstPositionMessage = true;
    
    
    try
    {
        count++;
        
        const BytesMessage* bytemessage = dynamic_cast<const BytesMessage*>(message);
        
        qDebug() << "Received message size: " << bytemessage->getBodyLength() ;
        //text = bytemessage->readString();
        
        //vector<unsigned char> buffer(bytemessage->getBodyLength());
        //bytemessage->readBytes(buffer);
        //qDebug() << "temp size: " << buffer.size() ;
        
        string text(bytemessage->getBodyLength(), '\0');
        bytemessage->readBytes((unsigned char *)text.c_str(), bytemessage->getBodyLength());
        
        /*
        try 
        {
            if( clientAck ) {
                message->acknowledge();
            }
        } 
        catch (CMSException& e) 
        {
            qDebug() << "acknowledge error (acknowlege mode = " << clientAck << " )";
            e.printStackTrace();
        }
         */
        
        ::cgl::pviz::rpc::PvizMessage pvizmessage;
        if (pvizmessage.ParseFromString(text))
        {
            //PvizModel::loadPvizMessage(pvizmessage);
            qDebug() << "model : " << model ;
            qDebug() << model->toString().c_str();
            
            
            if (pvizmessage.type() == ::cgl::pviz::rpc::PvizMessage_mtype_SYNC)
            {
                qDebug() << "Timestamp : " << pvizmessage.timestamp();
                qDebug() << "Don't care SYNC";
                return;
            }
            
            if (pvizmessage.type() == ::cgl::pviz::rpc::PvizMessage_mtype_FIN)
            {
                qDebug() << "Don't care FIN";
                return;
            }
            
            if (pvizmessage.labels().size() && isFirstLabelMessage)
            {
                isFirstLabelMessage = false;
                
                for (int i = 0; i < pvizmessage.labels().size(); i++)
                {
                    labels.push_back(pvizmessage.labels(i));
                }
            }
            
            if (pvizmessage.positions().size() > 0)
            {
                
                if (isFirstPositionMessage)
                {
                    isFirstPositionMessage = false;
                    
                    for (int i = 0; i < pvizmessage.positions().size(); i++)
                    {
                        Point3D pos;
                        
                        cgl::pviz::rpc::Position position = pvizmessage.positions(i);
                        pos.x = position.x();
                        pos.y = position.y();
                        pos.z = position.z();
                        
                        positions.push_back(pos);
                    }
                    
                    if (!isFirstLabelMessage)
                    {
                        qDebug() << "Creating model ... " ;
                        model->load(labels, positions);
                        modelStatus = 1;
                        emit OnModelCreated();
                        //loadModel();
                    }
                }
                else
                {
                    for (int i = 0; i < pvizmessage.positions().size(); i++)
                    {
                        Point3D pos = positions[i];
                        
                        cgl::pviz::rpc::Position position = pvizmessage.positions(i);
                        pos.x = position.x();
                        pos.y = position.y();
                        pos.z = position.z();
                        
                        positions[i] = pos;
                    }
                    
                    if (isFirstLabelMessage)
                    {
                        qDebug() << "Model is not initialized ... Skip." ;
                    }
                    else
                    {
                        qDebug() << "Updating model ... " ;
                        model->update(positions);
                        modelStatus = 2;
                        emit OnModelUpdated();
                        //updateModel();
                    }
                }
            }
        }
        else
        {
            BytesMessage* bmsg = bytemessage->clone();
            int type = bmsg->readInt();
            long long receivedTimestamp = bmsg->readLong();
            int stepid = bmsg->readInt();
            
            qDebug() << "type           : " << type;
            qDebug() << "timestamp      : " << receivedTimestamp;
            qDebug() << "stepid         : " << stepid;
            
            if (receivedTimestamp != timestamp)
            {
	        qDebug() << "Timestamp expected : " << timestamp;
                qDebug() << "Timestamp mismatch ... discard.";
                return;
            }
            
            switch (type) {
                case 0: // LABEL DATA
                {
                    int length = bmsg->readInt();                    
                    qDebug() << "length         : " << length;
                    
                    if ((20 + 4*length) != bmsg->getBodyLength())
                    {
                        qDebug() << "Currupted format detected (label data) ... ";
                        return;
                    }
                    
                    isFirstLabelMessage = false;
                    for (int i = 0; i < length; i++)
                    {
                        labels.push_back(bmsg->readInt());
                    }
                }
                    break;
                case 1: // POSITION DATA
                {
                    int length = bmsg->readInt();                    
                    int dim = bmsg->readInt();
                    qDebug() << "length         : " << length;
                    qDebug() << "dim            : " << dim;
                    
                    if ((24 + 8*length*dim) != bmsg->getBodyLength())
                    {
                        qDebug() << "Currupted format detected (position data) ... ";
                        qDebug() << "Expected : " << 24 + 8*length*dim;
                        qDebug() << "Received : " << bmsg->getBodyLength();
                        return;
                    }
                    
                    if (dim != 3)
                    {
                        qDebug() << "Currupted format detected (dimension mismatch) ... ";
                        return;
                    }
                    
                    if (isFirstPositionMessage)
                    {
                        isFirstPositionMessage = false;
                        
                        for (int i = 0; i < length; i++)
                        {
                            Point3D pos;
                            
                            pos.x = bmsg->readDouble();
                            pos.y = bmsg->readDouble();
                            pos.z = bmsg->readDouble();
                            
                            positions.push_back(pos);
                        }
                        
                        if (!isFirstLabelMessage)
                        {
                            qDebug() << "Creating model ... " ;
                            model->load(labels, positions);
                            modelStatus = 1;
                            emit OnModelCreated();
                            //loadModel();
                        }
                    }
                    else
                    {
                        for (int i = 0; i < length; i++)
                        {
                            Point3D pos = positions[i];
                            
                            pos.x = bmsg->readDouble();
                            pos.y = bmsg->readDouble();
                            pos.z = bmsg->readDouble();
                            
                            positions[i] = pos;
                        }
                        
                        if (isFirstLabelMessage)
                        {
                            qDebug() << "Model is not initialized ... Skip." ;
                        }
                        else
                        {
                            qDebug() << "Updating model ... " ;
                            model->update(positions);
                            modelStatus = 2;
                            emit OnModelUpdated();
                            //updateModel();
                        }
                    }
                }
                    break;
                case -1: // SYN
                    qDebug() << "Don't care SYNC";
                    break;
                case -2: // FIN
                {
                    qDebug() << "Don't care FIN";
                    /*
                    qDebug() << "FIN received ... Requesting again ... ";
                    
                    BytesMessage* message = session->createBytesMessage();
                    
                    message->writeInt(-1); // Label (0), Position (1), SYN (-1), FIN (-2)
                    qint64 msec = QDateTime::currentMSecsSinceEpoch();
                    timestamp = msec;
                    message->writeLong(timestamp);
                    message->writeInt(0); // Iteration
                    
                    producer->send( message );
                    delete message;    
                    */
                }
                    break;
                default:
                    break;
            }
        }
        
    } catch (CMSException& e) {
        qDebug() << "CMSException" ;
        e.printStackTrace();
    }
    
}

/*
void PvizWidget::ConnectToNBServer(string host, int port, int entityID, int templateId, string contentSynopsis)
{
    serviceClient = new ServiceClient();
    try
    {
        serviceClient->init(host, port, entityID, templateId);
        serviceClient->subscribe(contentSynopsis, this);
    }
    catch (ServiceException& e)
    {
        cout << e.getMessage() << endl;
        throw e;
    }
}

void PvizWidget::onEvent(NBEvent *nbEvent)
{
    char * payload=nbEvent->getContentPayload();
    int payloadSize=nbEvent->getPayloadLength();
    
    for(int i=0; i < payloadSize; i++)
    {
        printf("%c", *(payload+i));
    }
    cout<<endl<<"----------------------------------------------------- "<<endl;
}
*/
#endif

void PvizWidget::updateModel()
{
	vtkUnsignedIntArray *pids = (vtkUnsignedIntArray*)(plot->GetPointData()->GetArray(POINT_ID_NAME));
	vtkPoints *points = plot->GetPoints();
	
	QMap<unsigned int, PvizPoint*> points_(model->points);
	foreach(PvizPoint* point, points_)
	{
		vtkIdType pidx = pids->LookupValue(point->id);		
		points->SetPoint(pidx, point->position);
	}
	
    // OpenMP error. Critical Region
	// Update Pviz
	refresh();
	
	//this->ui->qvtkWidget->update();
	//renderer->ResetCamera();
	//renderer->Render();
	this->GetRenderWindow()->Render();
	outstandingRequest_ = false;
}

void PvizWidget::SetClusterLabel(unsigned int cid, std::string label)
{
	model->clusters[cid]->label = label;
	
	//vtkIdType idx = lut->GetIndex(cid);
	//legendActor->SetEntryString(idx, label.c_str());
	
	this->update();
}


void PvizWidget::SetClusterColor(unsigned int cid, QColor color)
{
    PvizCluster* cluster = model->clusters[cid];
    
    if (!cluster->IsDefault())
        cluster->SetColor(QColorToPviz(color));
    
    QColor col = cluster->IsDefault() ? defaultColor : color;
    
    vtkIdType idx = lut->GetIndex(cid);	
    lut->SetTableValue(idx, col.redF(), col.greenF(), col.blueF(), col.alphaF());
    //legendActor->SetEntryColor(idx, col.redF(), col.greenF(), col.blueF());
    
    // OpenMP error. Critical Region
	// Update Pviz
    refresh();
    
    emit OnClusterColorChanged(this, cid, col);
}

QColor PvizWidget::GetClusterColor(unsigned int cid)
{
    double rgba[4];
    vtkIdType idx = lut->GetIndex(cid);
    lut->GetTableValue(idx, rgba);
    
    QColor col;
    col.setRgbF(rgba[0], rgba[1], rgba[2], rgba[3]);
    return col;
}

QColor PvizWidget::GetModelClusterColor(unsigned int cid)
{
    PvizCluster* cluster = model->clusters[cid];
    double rgba[4];
    
    ColorMap_t type = GetColorMap();
    
    switch (type)
    {
        case MATLAB_DISTINCT:
        {
            int ncolor = sizeof(distinct) / sizeof(distinct[0]);
            
            rgba[0] = (double) distinct[cid % ncolor][0];
            rgba[1] = (double) distinct[cid % ncolor][1];
            rgba[2] = (double) distinct[cid % ncolor][2];
            rgba[3] = 1.0;            
        }
            break;
        case SALSA_CUSTOM:
        {
            int ncolor = sizeof(salsa17) / sizeof(salsa17[0]);
            
            rgba[0] = (double) salsa17[cid % ncolor][0];
            rgba[1] = (double) salsa17[cid % ncolor][1];
            rgba[2] = (double) salsa17[cid % ncolor][2];
            rgba[3] = 1.0;            
        }
            break;
        case COLORBREW_SET1:
        {
            int ncolor = sizeof(colorbrewer_set1) / sizeof(colorbrewer_set1[0]);
            
            rgba[0] = (double) colorbrewer_set1[cid % ncolor][0];
            rgba[1] = (double) colorbrewer_set1[cid % ncolor][1];
            rgba[2] = (double) colorbrewer_set1[cid % ncolor][2];
            rgba[3] = 1.0;            
        }
            break;
        case COLORBREW_PAIRED:
        {
            int ncolor = sizeof(colorbrewer_paired) / sizeof(colorbrewer_paired[0]);
            
            rgba[0] = (double) colorbrewer_paired[cid % ncolor][0];
            rgba[1] = (double) colorbrewer_paired[cid % ncolor][1];
            rgba[2] = (double) colorbrewer_paired[cid % ncolor][2];
            rgba[3] = 1.0;            
        }
            break;
        case CUSTOM:
        {
            QColor col = PvizToQColor(cluster->GetColor());
            rgba[0] = col.redF();
            rgba[1] = col.greenF();
            rgba[2] = col.blueF();
            rgba[3] = col.alphaF();
            
        }
            break;
        case RAINBOW:
        case RAINBOW_R:
        case COOL2WARM:
        case COOL2WARM_R:
        case JET:
        case JET_R:
        case HSV:
        case HOT:
        case EXPERIMENTAL:
        {
            cf->GetColor(cid, rgba);
            rgba[3] = 1.0;
        }
            break;
    }
    
    QColor col;
    col.setRedF(rgba[0]);
    col.setGreenF(rgba[1]);
    col.setBlueF(rgba[2]);
    col.setAlphaF(rgba[3]);
    
    return col;
}

void PvizWidget::UpdateLines()
{
	if (!cleansubplot) 
		return;
    
	cleansubplot->Update();
	
	QMap<unsigned int, PvizLine*> lines_(model->lines);
	vtkUnsignedIntArray *pids = vtkUnsignedIntArray::SafeDownCast(cleansubplot->GetOutput()->GetPointData()->GetArray(POINT_ID_NAME));
    
    if (!pids)
        return;
	
    if (!lineVisible)
        return;

    // Build lines
	VTK_CREATE(vtkCellArray, lines);
	
	foreach(PvizLine* line, lines_)
	{
		VTK_CREATE(vtkPolyLine, polyLine);
		polyLine->GetPointIds()->SetNumberOfIds(line->points.size());
		
		unsigned int i = 0;
		bool err = false;
		foreach(PvizPoint* point, line->points)
		{
			vtkIdType pidx = pids->LookupValue(point->id);
			if (pidx != -1) 
			{
				polyLine->GetPointIds()->SetId(i, pidx);
				i++;
			}
			else 
			{
				err = true;
				break;
			}
		}
		
		if (!err)
		{
			lines->InsertNextCell(polyLine);
		}		
	}
	cleansubplot->GetOutput()->SetLines(lines);
}

void PvizWidget::SetClusterVisible(unsigned int cid, bool visible)
{
	// PvizModel Update
	model->clusters[cid]->visible = visible;
	
	// list of cells to be selected
	//vtkIdTypeArray* selectedCellIds = vtkIdTypeArray::New();
	//selectedCellIds->Reset();
	
	QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
	vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);
	vtkIdType cidx = cids->LookupValue(cid);
	vtkIdType idx = selectedCellIds->LookupValue(cidx);
	
	if (visible) 
	{
		if (idx == -1)
		{
			selectedCellIds->InsertNextValue(cidx);
		}
	}
	else
	{
		if (idx != -1)
		{
			selectedCellIds->RemoveTuple(idx);
		}
	}

	// Update selectedCellIdsForGlyph
	updateSelectedCellIdsForGlyph(cid, visible);
	
    // OpenMP error. Critical region
	// Update Pviz
	//refresh();
    
    emit OnClusterVisibleChanged(this, cid, visible);
}

void PvizWidget::SetClusterAsDefault(unsigned int cid, bool isdefault)
{
    qDebug() << "SetClusterAsDefault" << cid << isdefault;
	// PvizModel Update
    PvizCluster* cluster = model->clusters[cid];
	cluster->SetAsDefault(isdefault);
    
    /*
	if (isdefault)
    {
        model->ClusterListMoveBack(cluster);
        //SetClusterColor(cid, QColor(PvizCluster::DefaultColor.ui_color));
        //SetClusterScale(cid, PvizCluster::DefaultScale);
    }
    else
    {
        model->ClusterListMoveFront(cluster);        
        //SetClusterColor(cid, GetClusterColor(cid));
        //SetClusterScale(cid, cluster->GetScale());
    }
    */
#pragma omp critical
    isdefault ? model->ClusterListMoveBack(cluster) : model->ClusterListMoveFront(cluster);
    
    QColor col = GetModelClusterColor(cid);
    SetClusterColor(cid, col);
    SetClusterScale(cid, cluster->GetScale());
    //qDebug() << "SetClusterAsDefault : " << isdefault << col;
    
    emit OnClusterDefaultChanged(this, cid, isdefault);
}

float PvizWidget::GetClusterScale(unsigned int cid)
{
    PvizCluster* cluster = model->clusters[cid];
    
	return cluster->IsDefault() ? defaultScale : cluster->GetScale();
    
}

void PvizWidget::SetClusterScale(unsigned int cid, float scale)
{
	// PvizModel Update
    PvizCluster* cluster = model->clusters[cid];
    
    if (!cluster->IsDefault())
        cluster->SetScale(scale);
    
    // Update graph 
    double l_scale = cluster->IsDefault() ? defaultScale : scale;
    	
	// PolyData Update
	vtkSmartPointer<vtkIdList> pidList = vtkSmartPointer<vtkIdList>::New();
	vtkUnsignedIntArray *pointcids = (vtkUnsignedIntArray *)plot->GetPointData()->GetArray(CLUSTER_ID_NAME);
	pointcids->LookupValue(cid, pidList);
	
	vtkFloatArray *pointScales = (vtkFloatArray *)plot->GetPointData()->GetArray(POINT_SCALE_NAME);
	
	for(vtkIdType i = 0; i < pidList->GetNumberOfIds(); i++)
    {
		vtkIdType pid = pidList->GetId(i);
		pointScales->SetValue(pid, l_scale);
    }
	
	// Update selectedCellIdsForGlyph
	updateSelectedCellIdsForGlyph(cid, l_scale != 0.0? true:false);
	
    // OpenMP error. Critical region
	// Update Pviz
	//refresh();
}

int PvizWidget::GetClusterShape(unsigned int cid)
{
    PvizCluster* cluster = model->clusters[cid];
    
    return cluster->shape;
}

void PvizWidget::SetClusterShape(unsigned int cid, int shape)
{
    //qDebug() << "SetClusterShape" << cid << shape;
    
    PvizCluster* cluster = model->clusters[cid];
    
    cluster->shape = shape;
    
	// PolyData Update
	vtkSmartPointer<vtkIdList> pidList = vtkSmartPointer<vtkIdList>::New();
	vtkUnsignedIntArray *pointcids = (vtkUnsignedIntArray *)plot->GetPointData()->GetArray(CLUSTER_ID_NAME);
	pointcids->LookupValue(cid, pidList);
	
	vtkUnsignedIntArray *pointShapes = (vtkUnsignedIntArray *)plot->GetPointData()->GetArray(SHAPE_ID_NAME);
	
	for(vtkIdType i = 0; i < pidList->GetNumberOfIds(); i++)
    {
		vtkIdType pid = pidList->GetId(i);
		pointShapes->SetValue(pid, shape);
    }
    
    // OpenMP error. Critical region
    // Update Pviz
	//refresh();
}

void PvizWidget::updateSelectedCellIdsForGlyph(unsigned int cid, bool visible)
{
	vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);
	vtkIdType cidx = cids->LookupValue(cid);
	vtkIdType idx = selectedCellIdsForGlyph->LookupValue(cidx);
	
	if (visible)
	{
		if (idx == -1)
		{
			selectedCellIdsForGlyph->InsertNextValue(cidx);
		}
	}
	else 
	{
		if (idx != -1)
		{
			selectedCellIdsForGlyph->RemoveTuple(idx);
		}
	}
}

void PvizWidget::reset()
{
	renderer->RemoveAllViewProps();
	delete model;
	model = new PvizModel();
}

void PvizWidget::RefreshAll()
{
    refresh();
}

void PvizWidget::refresh()
{
	this->plot->Modified();
	this->UpdateLines();
	this->update();
    // Not sure any performance implication due to frequent refreshing
    if (this->cleansubplotForGlyph) this->cleansubplotForGlyph->Update();
    if (this->cleansubplot) this->cleansubplot->Update();
}

void PvizWidget::SetAxesVisible(bool b)
{
	axesVisible = b;
	if (axesActor.GetPointer())
	{
		axesActor->SetVisibility(axesVisible);
	}
	this->update();	
}

bool PvizWidget::GetAxesVisible()
{
	return axesVisible;
}

bool PvizWidget::GetCubeAxesVisible()
{
	return cubeAxesVisible;
}

void PvizWidget::SetCubeAxesVisible(bool b)
{
	cubeAxesVisible = b;
    cubeAxesActor->SetVisibility(cubeAxesVisible);
	this->update();	
}

bool PvizWidget::GetCubeAxesResizeOnSelection()
{
	return cubeAxesResizeOnSelection;
}

void PvizWidget::SetCubeAxesResizeOnSelection(bool b)
{
	cubeAxesResizeOnSelection = b;
}

void PvizWidget::SetCubeAxesBounds(double val, int i)
{
    double bounds[6];
    cubeAxesActor->GetBounds(bounds);
    
    bounds[i] = val;
    cubeAxesActor->SetBounds(bounds);
	this->update();	
}

double PvizWidget::GetCubeAxesBounds(int i)
{
    double bounds[6];
    cubeAxesActor->GetBounds(bounds);
    
	return bounds[i];
}

void PvizWidget::SetCubeAxesDrawXGridlines(bool b)
{
    cubeAxesActor->SetDrawXGridlines(b);
	this->update();	
}

void PvizWidget::SetCubeAxesDrawYGridlines(bool b)
{
    cubeAxesActor->SetDrawYGridlines(b);
	this->update();	
}

void PvizWidget::SetCubeAxesDrawZGridlines(bool b)
{
    cubeAxesActor->SetDrawZGridlines(b);
	this->update();	
}

bool PvizWidget::GetCubeAxesDrawXGridlines()
{
	return cubeAxesActor->GetDrawXGridlines();
}

bool PvizWidget::GetCubeAxesDrawYGridlines()
{
	return cubeAxesActor->GetDrawYGridlines();
}

bool PvizWidget::GetCubeAxesDrawZGridlines()
{
	return cubeAxesActor->GetDrawZGridlines();
}

void PvizWidget::SetCubeAxesLabelScaleFactor(double factor)
{
    //TODO: fix
    //cubeAxesActor->SetLabelScaleFactor(factor);
	this->update();	
}

double PvizWidget::GetCubeAxesLabelScaleFactor()
{
    //TODO: fix
    //return cubeAxesActor->GetLabelScaleFactor();
    return 0;
}

/*
bool PvizWidget::GetScaleAxesVisible()
{
	return scaleAxesActor->GetVisibility();
}

void PvizWidget::SetScaleAxesVisible(bool b)
{
	scaleAxesActor->SetVisibility(b);
	this->update();	
}

void PvizWidget::SetScaleAxesLabelScale(int i, double scale)
{
    scaleAxesActor->SetLabelScale(i, scale);
	this->update();	    
}

double PvizWidget::GetScaleAxesLabelScale(int i)
{
    return scaleAxesActor->GetLabelScale(i);
}
*/

void PvizWidget::SetPlotVisible(bool b)
{
	plotVisible = b;
	if (plotActor.GetPointer())
	{
		plotActor->SetVisibility(plotVisible);
	}
	this->update();	
}

bool PvizWidget::GetPlotVisible()
{
	return plotVisible;
}

void PvizWidget::SetLineVisible(bool b)
{
    plotVisible = b;
    if (plotActor.GetPointer())
    {
        lineVisible = b;
    }
    this->refresh();
}

bool PvizWidget::GetLineVisible()
{
    return lineVisible;
}

void PvizWidget::SetPlotLineWidth(unsigned int width)
{
	plotLineWidth = width;
	if (plotActor.GetPointer())
	{
		plotActor->GetProperty()->SetLineWidth(plotLineWidth);
	}
	this->update();
}

unsigned int PvizWidget::GetPlotLineWidth()
{
	return plotLineWidth;
}

void PvizWidget::SetPlotPointSize(unsigned int size)
{
	plotPointSize = size;
	if (plotActor.GetPointer())
	{
		plotActor->GetProperty()->SetPointSize(plotPointSize);
	}
    
    //this->interactorStyle->SetDelta(size);
	this->update();	
}

unsigned int PvizWidget::GetPlotPointSize()
{
	return plotPointSize;
}

void PvizWidget::SetGlyphVisible(bool b)
{
	glyphVisible = b;
	
    if (glyphActor.GetPointer())
	{
		glyphActor->SetVisibility(glyphVisible);
	}
    
	if (glyphVisible)
	{
		renderer->AddObserver(vtkCommand::EndEvent, cbGlyph);
		//renderer->Render();
	}
	else
	{
		renderer->RemoveObserver(cbGlyph);
	}
    
	this->update();	
}

bool PvizWidget::GetGlyphVisible()
{
	return glyphVisible;
}

void PvizWidget::SetGlyphAutoOrientation(bool b)
{
	glyphAutoOrientation = b;
	
    if (GetGlyphVisible() && GetGlyphAutoOrientation())
    {
        UpdateTransform();
    }

	this->update();	
}

bool PvizWidget::GetGlyphAutoOrientation()
{
	return glyphAutoOrientation;
}

void PvizWidget::SetGlyphScaleFactor(double factor)
{
	glyphScaleFactor = factor;
	if (glyph.GetPointer())
	{
		glyph->SetScaleFactor(glyphScaleFactor);
	}
	this->update();	
}

double PvizWidget::GetGlyphScaleFactor()
{
	return glyphScaleFactor;
}

void PvizWidget::ApplyColorMap(ColorMap_t type)
{
	//QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
	
	vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);
	
	double cidsRange[2];
	cids->GetRange(cidsRange);

    double r0 = cidsRange[0];
    double r1 = cidsRange[1];
    double rd = r1 - r0;
    double p1, p2, p3, p4;

    cf->RemoveAllPoints();
    bool iscfon = false;
    
    switch(type)
    {
        case CUSTOM:
        {
            foreach(PvizCluster* cluster, clusters_)
            {
                double rgb[3];
                rgb[0] = cluster->GetColor()->uc_color.r/255.0;
                rgb[1] = cluster->GetColor()->uc_color.g/255.0;
                rgb[2] = cluster->GetColor()->uc_color.b/255.0;
                
                vtkIdType idx = lut->GetIndex(cluster->id);
                lut->SetTableValue(idx, rgb[0], rgb[1], rgb[2]);
            }
        }
            break;
        case RAINBOW:
            iscfon = true;
            cf->SetColorSpaceToHSV();
            cf->HSVWrapOff();
            cf->AddRGBPoint(r0,            red[0], red[1], red[2]);
            cf->AddRGBPoint(r0 + rd * 0.5, green[0], green[1], green[2]);
            cf->AddRGBPoint(r1,            blue[0], blue[1], blue[2]);
            break;
        case RAINBOW_R:
            iscfon = true;
            cf->SetColorSpaceToHSV();
            cf->HSVWrapOff();
            cf->AddRGBPoint(r1,            red[0], red[1], red[2]);
            cf->AddRGBPoint(r0 + rd * 0.5, green[0], green[1], green[2]);
            cf->AddRGBPoint(r0,            blue[0], blue[1], blue[2]);
            break;
        case COOL2WARM:
            iscfon = true;
            cf->SetColorSpaceToDiverging();
            cf->AddRGBPoint(r0, 0.230, 0.299, 0.754);
            cf->AddRGBPoint(r1, 0.706, 0.016, 0.150);
            break;
        case COOL2WARM_R:
            iscfon = true;
            cf->SetColorSpaceToDiverging();
            cf->AddRGBPoint(r0, 0.706, 0.016, 0.150);
            cf->AddRGBPoint(r1, 0.230, 0.299, 0.754);
            break;
        case JET:
            iscfon = true;
            cf->SetColorSpaceToHSV();
            cf->HSVWrapOff();
            cf->AddRGBPoint(r0,            blue_pure[0], blue_pure[1], blue_pure[2]);
            cf->AddRGBPoint(r0 + rd * 0.5, green_pure[0], green_pure[1], green_pure[2]);
            cf->AddRGBPoint(r1,            red_pure[0], red_pure[1], red_pure[2]);
            break;
        case JET_R:
            iscfon = true;
            cf->SetColorSpaceToHSV();
            cf->HSVWrapOff();
            cf->AddRGBPoint(r1,            blue_pure[0], blue_pure[1], blue_pure[2]);
            cf->AddRGBPoint(r0 + rd * 0.5, green_pure[0], green_pure[1], green_pure[2]);
            cf->AddRGBPoint(r0,            red_pure[0], red_pure[1], red_pure[2]);
            break;
        case HSV:
            iscfon = true;
            cf->SetColorSpaceToHSV();
            cf->AddHSVPoint(r0, 0.0, 1.0, 1.0);
            cf->AddHSVPoint(r0 + rd * 0.5, 0.5, 1.0, 1.0);
            cf->AddHSVPoint(r1, 0.999999, 1.0, 1.0);
            break;
        case HOT:
            iscfon = true;
            cf->SetColorSpaceToRGB();
            p1 = 0.0 / 8.0;
            p2 = 3.0 / 8.0;
            p3 = 6.0 / 8.0;
            p4 = 8.0 / 8.0;
            cf->AddRGBPoint(r0,           0, 0, 0);
            cf->AddRGBPoint(r0 + rd * p2, 1, 0, 0);
            cf->AddRGBPoint(r0 + rd * p3, 1, 1, 0);
            cf->AddRGBPoint(r1,           1, 1, 1);
            break;
        case EXPERIMENTAL:
            iscfon = true;
            cf->SetColorSpaceToDiverging();
            cf->HSVWrapOff();
            cf->AddHSVPoint(r0, 0.0, 1.0, 1.0);
            cf->AddHSVPoint(r1, 0.66667, 1.0, 1.0);
            break;
        case COLORBREW_SET1:
        {
            int ncolor = sizeof(colorbrewer_set1) / sizeof(colorbrewer_set1[0]);
            
            foreach(PvizCluster* cluster, clusters_)
            {
                double rgb[3];
                rgb[0] = (double) colorbrewer_set1[cluster->id % ncolor][0];
                rgb[1] = (double) colorbrewer_set1[cluster->id % ncolor][1];
                rgb[2] = (double) colorbrewer_set1[cluster->id % ncolor][2];
                
                vtkIdType idx = lut->GetIndex(cluster->id);
                lut->SetTableValue(idx, rgb[0], rgb[1], rgb[2]);
            }
            
        }
            break;
        case COLORBREW_PAIRED:
        {
            int ncolor = sizeof(colorbrewer_paired) / sizeof(colorbrewer_paired[0]);
            
            foreach(PvizCluster* cluster, clusters_)
            {
                double rgb[3];
                rgb[0] = (double) colorbrewer_paired[cluster->id % ncolor][0];
                rgb[1] = (double) colorbrewer_paired[cluster->id % ncolor][1];
                rgb[2] = (double) colorbrewer_paired[cluster->id % ncolor][2];
                
                vtkIdType idx = lut->GetIndex(cluster->id);
                lut->SetTableValue(idx, rgb[0], rgb[1], rgb[2]);
            }
            
        }
            break;
        case MATLAB_DISTINCT:
        {
            int ncolor = sizeof(distinct) / sizeof(distinct[0]);
            
            foreach(PvizCluster* cluster, clusters_)
            {
                double rgb[3];
                rgb[0] = (double) distinct[cluster->id % ncolor][0];
                rgb[1] = (double) distinct[cluster->id % ncolor][1];
                rgb[2] = (double) distinct[cluster->id % ncolor][2];
                
                vtkIdType idx = lut->GetIndex(cluster->id);
                lut->SetTableValue(idx, rgb[0], rgb[1], rgb[2]);
            }
        }
            break;
        case SALSA_CUSTOM:
        {
            int ncolor = sizeof(salsa17) / sizeof(salsa17[0]);
            
            foreach(PvizCluster* cluster, clusters_)
            {
                double rgb[3];
                rgb[0] = (double) salsa17[cluster->id % ncolor][0];
                rgb[1] = (double) salsa17[cluster->id % ncolor][1];
                rgb[2] = (double) salsa17[cluster->id % ncolor][2];
                
                vtkIdType idx = lut->GetIndex(cluster->id);
                lut->SetTableValue(idx, rgb[0], rgb[1], rgb[2]);
            }
            
        }
            break;
        default:
            break;
    }

    if (iscfon)
    {
        for (int i = r0; i <= r1; i++)
        {
            double rgb[3];
            cf->GetColor(i, rgb);
            vtkIdType idx = lut->GetIndex(i);
            lut->SetTableValue(idx, rgb[0], rgb[1], rgb[2]);
        }
    }

    foreach(PvizCluster* cluster, clusters_)
    {
        if (cluster->IsDefault())
        {
            vtkIdType idx = lut->GetIndex(cluster->id);
            lut->SetTableValue(idx,
                               defaultColor.redF(), 
                               defaultColor.greenF(), 
                               defaultColor.blueF(), 
                               defaultColor.alphaF());
        }
    }    
}

void PvizWidget::SetBackgroundColor(QColor color)
{
	backgroundColor_ = color;
	renderer->SetBackground(backgroundColor_.redF(), backgroundColor_.greenF(), backgroundColor_.blueF());
	
	this->update();
}

QColor& PvizWidget::GetBackgroundColor()
{
	return backgroundColor_;
}

void PvizWidget::SetColorMap(ColorMap_t type)
{
	colorMap_ = type;
	
	if (!plot.GetPointer())
		return;
	
	ApplyColorMap(colorMap_);
	
	refresh();
}

PvizWidget::ColorMap_t PvizWidget::GetColorMap()
{
	return colorMap_;
}

void PvizWidget::BuildLegend()
{
	//VTK_CREATE(vtkLegendBoxActor, legendActor);
	//VTK_ASSIGN(vtkLegendBoxActor, legendActor);
	// Show only visible clusters
	//QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
	
	int i = 0;
	foreach(PvizCluster* cluster, clusters_)
	{
		if ((cluster->visible) && (!cluster->IsDefault()))
		{
            i++;
        }
    }
	legendActor->SetNumberOfEntries(i);
	
	VTK_CREATE(vtkCubeSource, source);
	vtkSmartPointer<vtkPolyData> sym = source->GetOutput();
    source->Update();
    
	i = 0;
	foreach(PvizCluster* cluster, clusters_)
	{
		if ((cluster->visible) && (!cluster->IsDefault()))
		{
			//vtkUnsignedIntArray *cids = (vtkUnsignedIntArray *)plot->GetFieldData()->GetArray(CELL_ID_NAME);
			//vtkIdType cidx = cids->LookupValue(cid);

			double rgba[4];
            vtkIdType idx = lut->GetIndex(cluster->id);
			lut->GetTableValue(idx, rgba);
			
            char buffer[80];
			//legendActor->SetEntry(i, legendSphere, cluster->label.c_str(), rgba);
			if (cluster->label.empty())
			{
				sprintf(buffer, "%d (%lu)", cluster->id, cluster->points.size());
				legendActor->SetEntry(i, sym, buffer, rgba);
			}
			else 
			{
				sprintf(buffer, "%s (%lu)", cluster->label.c_str(), cluster->points.size());
				legendActor->SetEntry(i, sym, buffer, rgba);
			}

			i++;
		}
	}
	
    SetLegendPosition(legendPosition);
	legendActor->BorderOn();
    //legendActor->BorderOff();
	legendActor->LockBorderOn();
	//legendActor->LockBorderOff();
	//legendActor->SetPosition2(legendWidthFactor, 1.0);
	//legendActor->SetHeight(legendHeightFactor);
	//legendActor->SetWidth(legendWidthFactor);
	legendActor->SetPadding(2);
	legendActor->SetVisibility(legendVisible);
	legendActor->GetEntryTextProperty()->SetVerticalJustificationToCentered();
	legendActor->GetEntryTextProperty()->SetFontSize(10);
    
	renderer->AddActor(legendActor);	
}

void PvizWidget::SetLegendVisible(bool b)
{
	legendVisible = b;
	legendActor->SetVisibility(legendVisible);
	
	if (legendVisible)
	{
        BuildLegend();
        /*
        if (selectedNeighbors->GetNumberOfIds() > 0)
        {
            BuildLegendSelected();
        }
        else
        {
            BuildLegend();
        }
         */
	}
	
	this->update();
}

bool PvizWidget::GetLegendVisible()
{
	return legendVisible;
}


void PvizWidget::SetLegendHeightFactor(double height)
{
	legendHeightFactor = height;
    SetLegendPosition(legendPosition);
    //legendActor->SetHeight(legendHeightFactor);
    
	this->update();
}

double PvizWidget::GetLegendHeightFactor()
{
	return legendHeightFactor;
}

void PvizWidget::SetLegendWidthFactor(double width)
{
	legendWidthFactor = width;
    SetLegendPosition(legendPosition);
	//legendActor->SetWidth(legendWidthFactor);
    
	this->update();
}

double PvizWidget::GetLegendWidthFactor()
{
	return legendWidthFactor;
}

void PvizWidget::SetLegendPosition(LegendLocation_t loc)
{
    legendPosition = loc;
    double pad = 0.005;
    
    // Set position (lower left corner) and position2 (upper right)    
    switch(legendPosition)
    {
        case UPPERLEFT:
            legendActor->SetPosition(0.0 + pad, 1.0 - legendHeightFactor - pad);
            break;
        case UPPERRIGHT:
            legendActor->SetPosition(1.0 - legendWidthFactor - pad, 1.0 - legendHeightFactor - pad);
            break;
        case LOWERLEFT:
            legendActor->SetPosition(0.0 + pad, 0.0 + pad);
            break;
        case LOWERRIGHT:
            legendActor->SetPosition(1.0 - legendWidthFactor - pad, 0.0 + pad);
            break;
    }
    legendActor->SetHeight(legendHeightFactor);
	legendActor->SetWidth(legendWidthFactor);
    
    /*
    qDebug() << "legendPosition" << legendPosition;
    double *pos, *pos2;
    pos = legendActor->GetPosition();
    pos2 = legendActor->GetPosition2();
    qDebug() << "legendPosition" << pos[0] << pos[1];
    qDebug() << "legendPosition" << pos2[0] << pos2[1];
     */
    
}

PvizWidget::LegendLocation_t PvizWidget::GetLegendPosition()
{
    return legendPosition;
}

void PvizWidget::SetColorbarVisible(bool b)
{
    colorbarVisible = b;
    colorbarActor->SetVisibility(colorbarVisible);
    
    this->update();
}

bool PvizWidget::GetColorbarVisible()
{
    return colorbarVisible;
}

void PvizWidget::SetColorbarNumberOfLabels(int num)
{
    colorbarNumberOfLabels = num;
    colorbarActor->SetNumberOfLabels(colorbarNumberOfLabels);
    
    this->update();
}

int PvizWidget::GetColorbarNumberOfLabels()
{
    return colorbarNumberOfLabels;
}

int PvizWidget::SaveScreen(QString filename)
{
	// Screenshot  
	//vtkSmartPointer<vtkWindowToImageFilter> windowToImageFilter = vtkSmartPointer<vtkWindowToImageFilter>::New();
	VTK_CREATE(vtkWindowToImageFilter, windowToImageFilter);
	windowToImageFilter->SetInput(this->GetRenderWindow());
	windowToImageFilter->SetMagnification(1); //set the resolution of the output image (3 times the current resolution of vtk render window)
    windowToImageFilter->SetInputBufferTypeToRGB(); //RGBA generates transparent backgrounds
	windowToImageFilter->Update();
	
	//vtkSmartPointer<vtkPNGWriter> writer = vtkSmartPointer<vtkPNGWriter>::New();
	VTK_CREATE(vtkPNGWriter, writer);
	writer->SetFileName(filename.toAscii().data());
#if VTK_MAJOR_VERSION <= 5
	writer->SetInput(windowToImageFilter->GetOutput());
#else
    writer->SetInputData(windowToImageFilter->GetOutput());
#endif
	writer->Write();
	
	return SUCCESS;
}

int PvizWidget::SaveAsMovie(QString filename)
{
#ifdef _WIN32 
	VTK_CREATE(vtkWindowToImageFilter, windowToImageFilter);
	windowToImageFilter->SetInput(this->GetRenderWindow());
	
	VTK_CREATE(vtkAVIWriter, w);
	w->SetCompressorFourCC("MSVC");
	w->SetFileName(filename.toAscii().data());
#if VTK_MAJOR_VERSION <= 5
	w->SetInput(windowToImageFilter->GetOutput());
#else
	w->SetInputData(windowToImageFilter->GetOutput());
#endif
	w->SetRate(20);
	qDebug() << "Rate : " << w->GetRate();
	qDebug() << "Quality : " << w->GetQuality();
	w->Start();
	for (int i = 0; i < 360; ++i)
	{
		// Render the image and rotate the active camera by one degree
		this->GetRenderWindow()->Render();
		renderer->GetActiveCamera()->Azimuth(-1);
		windowToImageFilter->Modified();
		w->Write();
	}
	w->End();
	qDebug() << "Saved animation : " << filename;
#endif
    return SUCCESS;
}

void PvizWidget::SetVisibleMode(VisibleMode_t mode)
{
	visibleMode_ = mode;
	
	if (visibleMode_ == PvizWidget::HALF)
	{
		double d[2];
		renderer->GetActiveCamera()->GetClippingRange(d);
		cameraClippingDistance_ = d[1];
		d[1] = renderer->GetActiveCamera()->GetDistance();
		renderer->GetActiveCamera()->SetClippingRange(d);
	}
    /*
	else 
	{
		double d[2];
		renderer->GetActiveCamera()->GetClippingRange(d);
		d[1] = cameraClippingDistance_;
		renderer->GetActiveCamera()->SetClippingRange(d);
	}
	*/
    
	this->update();	
}

PvizWidget::VisibleMode_t PvizWidget::GetVisibleMode()
{
	return visibleMode_;
}

void PvizWidget::ResetCameraClippingRangeEventCallBack(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
	if (self->GetVisibleMode() == PvizWidget::HALF)
	{
		double d[2];
		vtkRenderer *renderer = static_cast<vtkRenderer*>(caller);
		renderer->GetActiveCamera()->GetClippingRange(d);
		
		d[1] = renderer->GetActiveCamera()->GetDistance();
		renderer->GetActiveCamera()->SetClippingRange(d);
	}
    
    double d[2];
    vtkCamera* camera = self->GetActiveCamera();
    camera->GetClippingRange(d);
    if (d[0] > camera->GetDistance())
    {
        //qDebug() << "Resetting ClippingRange: (" << d[0] << "," << d[1] << ")";
        //d[1] = camera->GetDistance();
        d[0] = 0.0001;
		camera->SetClippingRange(d);
    }
}

void PvizWidget::AreaPickerCallBack(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	//qDebug() << "AreaPickerCallBack ...";
	
	PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
	
	if (!self->plot)
		return;
	
	vtkPlanes* frustum = static_cast<vtkAreaPicker*>(caller)->GetFrustum();	
	
	vtkSmartPointer<vtkExtractGeometry> ex = vtkSmartPointer<vtkExtractGeometry>::New();
	ex->SetImplicitFunction(frustum);
#if VTK_MAJOR_VERSION <= 5
	ex->SetInput(self->cleansubplot->GetOutput());
#else
    ex->SetInputData(self->cleansubplot->GetOutput());
#endif
	//ex->Update();
	
	VTK_CREATE(vtkVertexGlyphFilter, glyphFilter);
	glyphFilter->SetInputConnection(ex->GetOutputPort());
	glyphFilter->Update();
	
	vtkPolyData* selected = glyphFilter->GetOutput();
	qDebug() << "Selected " << selected->GetNumberOfPoints() << " points.";
	
	vtkUnsignedIntArray* ids = vtkUnsignedIntArray::SafeDownCast(glyphFilter->GetOutput()->GetPointData()->GetArray(POINT_ID_NAME));
	vtkUnsignedIntArray* pids = vtkUnsignedIntArray::SafeDownCast(self->plot->GetPointData()->GetArray(POINT_ID_NAME));
	
    for(vtkIdType i = 0; i < ids->GetNumberOfTuples(); i++)
    {
        vtkIdType pidx = pids->LookupValue(ids->GetValue(i));
        //vtkIdType selectedidx = self->selectedPointIds->LookupValue(pidx);
        
        self->addToSelectedPoint(pidx, self->GetInteractor()->GetControlKey());
        
        /*
        if (selectedidx >= 0)
        {
            if (!self->GetInteractor()->GetShiftKey())
            {
                self->selectedPointIds->SetValue(selectedidx, -1);
            }
        }
        else 
        {
            self->selectedPointIds->InsertNextValue(pidx);
        }
         */
    }
    
    if (self->cubeAxesVisible && self->cubeAxesResizeOnSelection)
    {
        self->cubeAxesActor->SetBounds(ex->GetOutput()->GetBounds());
    }
    
    emit self->OnSelected();
    
	self->refresh();

    /*
    switch(self->interactorStyle->GetPickMode())
    {
        case pvizInteractorStyle::PickWhileHovering:
            qDebug() << "Picked while hovering ... ";
            
            for(vtkIdType i = 0; i < ids->GetNumberOfTuples(); i++)
            {
                vtkIdType pidx = pids->LookupValue(ids->GetValue(i));
                vtkIdType selectedidx = self->hoveredPointIds->LookupValue(pidx);
                //qDebug() << "selectedidx" << selectedidx;
                
                if (selectedidx >= 0)
                {
                    if (!self->GetInteractor()->GetShiftKey())
                    {
                        self->hoveredPointIds->SetValue(selectedidx, -1);
                    }
                }
                else 
                {
                    
                    self->hoveredPointIds->InsertNextValue(pidx);
                }
                
                PvizPoint * point = self->model->points[ids->GetValue(i)];
                self->interactorStyle->SetFlyToPos(point->position);
                break;
            }
            break;
        case pvizInteractorStyle::PickWhileSelecting:
            qDebug() << "Picked while selecting ... ";
            
            for(vtkIdType i = 0; i < ids->GetNumberOfTuples(); i++)
            {
                vtkIdType pidx = pids->LookupValue(ids->GetValue(i));
                vtkIdType selectedidx = self->selectedPointIds->LookupValue(pidx);
                
                if (selectedidx >= 0)
                {
                    if (!self->GetInteractor()->GetShiftKey())
                    {
                        self->selectedPointIds->SetValue(selectedidx, -1);
                    }
                }
                else 
                {
                    self->selectedPointIds->InsertNextValue(pidx);
                }
            }
            
            if (self->cubeAxesVisible && self->cubeAxesResizeOnSelection)
            {
                self->cubeAxesActor->SetBounds(ex->GetOutput()->GetBounds());
            }
            
            emit self->OnSelected();
            break;        
    }
    */
}

void PvizWidget::PickerCallBack(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	//qDebug() << "PickerCallBack ...";
	
	PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
	
	if (!self->plot)
		return;
    
    vtkIdType pickedPointId;
    vtkActor *pickedActor;
    double *pos;
   
    // Assume only two pickers: pointPicker and cellPicker
    vtkPointPicker* pointPicker = vtkPointPicker::SafeDownCast(caller);
    vtkCellPicker* cellPicker = vtkCellPicker::SafeDownCast(caller);
    //vtkPropPicker* propPicker = vtkPropPicker::SafeDownCast(caller);
    
    if (pointPicker)
    {
        pickedPointId = pointPicker->GetPointId();
        pickedActor = pointPicker->GetActor();
        pos = pointPicker->GetPickPosition();
    }
    else if (cellPicker)
    {
        pickedPointId = cellPicker->GetPointId();
        pickedActor = cellPicker->GetActor();
        pos = cellPicker->GetPickPosition();
    }
    /*
    else if (propPicker)
    {
        pos = propPicker->GetPickPosition();
        qDebug() << "Picked Position : (" << pos[0] << "," << pos[1] << "," <<  pos[2] << ")";
        qDebug() << "Picked actor    : " << propPicker->GetActor();
        return;
    }
     */
    else
    {
        return;
    }
    
    //qDebug() << "Picked point id : " << pickedPointId;
    //qDebug() << "Picked actor    : " << pickedActor;
    //qDebug() << "Picked Position : (" << pos[0] << "," << pos[1] << "," <<  pos[2] << ")";
  
    // Note:
    // picker->GetPointId() is came from self->cleansubplot.
    // We need an index from self->plot
	vtkUnsignedIntArray* plotPids = vtkUnsignedIntArray::SafeDownCast(self->plot->GetPointData()->GetArray(POINT_ID_NAME));
    self->interactorStyle->SetFlyToPos(pos);
    
    switch (self->GetInteractorMode()) 
    {
        case PvizWidget::PICKCENTER_MODE:
            self->SetInteractorMode(PvizWidget::INTERACT_MODE);
            self->SetLookAt(pos);
            
            emit self->OnCameraFocusChanged(self, pos);
            break;
            
        case PvizWidget::INTERACT_MODE:
            if (pickedActor == self->plotActor.GetPointer())
            {
                //qDebug() << "Picked plot";
                vtkUnsignedIntArray* cleansubplotPids = vtkUnsignedIntArray::SafeDownCast(self->cleansubplot->GetOutput()->GetPointData()->GetArray(POINT_ID_NAME));

                vtkIdType plotPointId = plotPids->LookupValue(cleansubplotPids->GetValue(pickedPointId));
                qDebug() << "Picked point id (converted): " << plotPointId;
                
                //self->hoveredPointIds->InsertNextValue(plotPointId);
                self->addToSelectedPoint(plotPointId, self->GetInteractor()->GetControlKey());
                
                self->refresh();
            }
            else if (pickedActor == self->glyphActor.GetPointer())
            {
                //qDebug() << "Picked glyph";
                vtkDataArray *inputIds = self->glyph->GetOutput()->GetPointData()->GetArray("InputPointIds");
                vtkUnsignedIntArray* cleansubplotForGlyphPids = vtkUnsignedIntArray::SafeDownCast(self->cleansubplotForGlyph->GetOutput()->GetPointData()->GetArray(POINT_ID_NAME));
                
                vtkIdType selectedPointId = inputIds->GetTuple1(pickedPointId);
                //qDebug() << "Picked glyph id : " << selectedPointId;
                //qDebug() << "Picked pid" << cleansubplotForGlyphPids->GetValue(selectedPointId);
                
                vtkIdType plotPointId = plotPids->LookupValue(cleansubplotForGlyphPids->GetValue(selectedPointId));
                
                qDebug() << "Picked point id (converted): " << plotPointId;
                
                //self->hoveredPointIds->InsertNextValue(plotPointId);        
                self->addToSelectedPoint(plotPointId, self->GetInteractor()->GetControlKey());
                
                self->refresh();
            }
            else if (cellPicker && (pickedActor == NULL))
            {
                //qDebug() << "Nothing is selected ... Try again";
                self->GetInteractor()->SetPicker(self->pointPicker);
                self->interactorStyle->HoverPick();
            }
            
            if (pointPicker)
            {
                self->GetInteractor()->SetPicker(self->cellPicker);
            }
            
            break;
            
        default:
            break;
    }    
}

PvizWidget::InteractorMode_t PvizWidget::GetInteractorMode()
{
	return interactorMode_;
}

void PvizWidget::SetInteractorMode(InteractorMode_t mode)
{
	interactorMode_ = mode;
	vtkRenderWindowInteractor* interactor = this->GetInteractor();  
	switch (mode) 
	{
		case INTERACT_MODE:
			interactorStyle->EndSelect();
			interactor->DestroyTimer(playTimer_);
            interactor->RemoveObserver(cbPickCenter);
            interactor->SetPicker(cellPicker);
            setHoverTimerActivate(labelVisible);
			break;
		case SELECT_MODE:
			interactorStyle->StartSelect();
            setHoverTimerActivate(false);
			interactor->DestroyTimer(playTimer_);
            interactor->RemoveObserver(cbPickCenter);
            interactor->SetPicker(areaPicker);
			break;
		case PLAY_MODE:
			interactorStyle->EndSelect();
			//interactor->DestroyTimer(hoverTimer_);
            setHoverTimerActivate(false);
			playTimer_ = interactor->CreateRepeatingTimer(playTimerDuration_);
            interactor->RemoveObserver(cbPickCenter);
            interactor->SetPicker(cellPicker);
			break;
		case PICKCENTER_MODE:
			interactorStyle->EndSelect();
			//interactor->DestroyTimer(hoverTimer_);
            setHoverTimerActivate(false);
			interactor->DestroyTimer(playTimer_);
            interactor->AddObserver(vtkCommand::LeftButtonPressEvent, cbPickCenter);
            interactor->SetPicker(cellPicker);
			break;
		default:
			break;
	}
}

void PvizWidget::InteractorTimerEvent(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	//qDebug() << "InteractorTimerEvent ... ";
	
	int timerId = *(reinterpret_cast<int*>(callData));
	
	PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
    
	if (!self->plot)
		return;
    
	if (timerId == self->playTimer_)
	{
        //qDebug() << "playTimer_ ... ";
		self->renderer->GetActiveCamera()->Azimuth(-1);
		self->GetInteractor()->GetRenderWindow()->Render();	
	}
    else if ((timerId == self->hoverTimer_) && self->underMouse())
    {
        //qDebug() << "hoverTimer_ ... ";
        //self->GetInteractor()->SetPicker(self->propPicker);
        self->interactorStyle->HoverPick();
        //self->setHoverTimerActivate(self->labelVisible);
        if (!self->hasFocus())
            self->setFocus();
        
        /*
        if ((self->GetInteractorMode() != PvizWidget::PLAY_MODE) && (self->labelVisible)) 
        {
            self->interactorStyle->HoverPick();
        }
         */
    }
    
}


void PvizWidget::HoverCallBack(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	//qDebug() << "HoverCallBack ... ";
    
	//int timerId = *(reinterpret_cast<int*>(callData));
	int timerId;
	PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
	//qDebug() << "Has Focus? " << self->hasFocus();
    
	if (!self->plot)
		return;
	
    if (self->GetInteractorMode() == PvizWidget::PICKCENTER_MODE)
        return;
    
	//qDebug() << "eventId : " << eventId;	
	switch (eventId) 
	{
		case vtkCommand::LeftButtonPressEvent:
		case vtkCommand::MiddleButtonPressEvent:
		case vtkCommand::RightButtonPressEvent:
		case vtkCommand::MouseWheelForwardEvent:
		case vtkCommand::MouseWheelBackwardEvent:
		case vtkCommand::MouseMoveEvent:
		case vtkCommand::KeyPressEvent:
            if (self->hoverTimer_)
			{
                self->setHoverTimerActivate(true);
			}
			break;
		case vtkCommand::EndInteractionEvent:
            /*
            qDebug() << "EndInteractionEvent ... ";
			if (self->GetGlyphVisible() && self->GetGlyphAutoOrientation())
			{
                self->UpdateTransform();
            }
             */
			break;
	}
}

void PvizWidget::RendererEndCallBack(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	//qDebug() << "RendererEndCallBack - eventId : " << eventId;	
	switch (eventId) 
	{
		case vtkCommand::EndEvent:
			PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
			
			if (self->GetFPSVisible())
			{
				double timeInSeconds = self->renderer->GetLastRenderTimeInSeconds();
				double fps = 1.0/timeInSeconds;
				sprintf(self->fps_str, "FPS : %8.03f", fps);
				if (self->cornerAnnotation)
				{
					self->cornerAnnotation->SetText(3, self->fps_str);
				}
			}
			
			if (self->GetGlyphVisible() && self->GetGlyphAutoOrientation())
			{
                self->UpdateTransform();
            }
            
            // Testing ...
            //vtkRenderWindowInteractor* interactor = self->GetInteractor(); 
            //qDebug() << "GetStillUpdateRate :" << interactor->GetStillUpdateRate();
            //qDebug() << "GetDesiredUpdateRate :" << interactor->GetDesiredUpdateRate();
            
			break;
	}
}

void PvizWidget::UpdateTransform()
{
    if (anyClusterHasGlyph2D())
    {
        double dir[3];
        this->GetActiveCamera()->GetViewPlaneNormal(dir);
        
        gs00->SetNormal(dir);
        gs01->SetNormal(dir);
        gs02->SetNormal(dir);
        gs03->SetNormal(dir);
    }
}

void PvizWidget::PickCenterCallBack(vtkObject* caller, unsigned long eventId, void* clientData, void* callData)
{
	//qDebug() << "PickCenterCallBack ... ";
	PvizWidget* self = reinterpret_cast<PvizWidget*>(clientData);
	
	if (!self->plot)
		return;
	
	//qDebug() << "eventId : " << eventId;	
	switch (eventId) 
	{
		case vtkCommand::LeftButtonPressEvent:
            self->interactorStyle->StopState();
            self->interactorStyle->HoverPick();
            emit self->OnCenterPicked();
			break;
	}
}


void PvizWidget::SetFPSVisible(bool b)
{
	fpsVisible = b;
	cornerAnnotation->SetVisibility(fpsVisible);
	
	if (fpsVisible)
	{
		renderer->AddObserver(vtkCommand::EndEvent, cbFPS);
		renderer->Render();
	}
	else
	{
		renderer->RemoveObserver(cbFPS);
	}
	
	this->update();
	renderer->Render();
}

bool PvizWidget::GetFPSVisible()
{
	return fpsVisible;
}

void PvizWidget::SetAsActiveCamera(vtkCamera *camera)
{
	if (camera == NULL)
	{
		UseLocalCamera();
	}
	else 
	{
		renderer->SetActiveCamera(camera);
		useSyncCamera = true;
	}
}

vtkCamera* PvizWidget::GetActiveCamera()
{
	return renderer->GetActiveCamera();
}

void PvizWidget::UseLocalCamera()
{
	if (useSyncCamera) 
	{
		localCamera->DeepCopy(renderer->GetActiveCamera());
	}
	renderer->SetActiveCamera(localCamera);
	useSyncCamera = false;
}

bool PvizWidget::GetUseSyncCamera()
{
	return useSyncCamera;
}

void PvizWidget::closeEvent(QCloseEvent *event)
{
    qDebug() << "PvizWidget ... closing";
	if (sync_) 
	{
		sync_->RemoveMember(this);
	}
    
    emit OnClosing(this);
    
	event->accept();
}

void PvizWidget::SetSync(PvizSync* sync)
{
	sync_ = sync;
}

void PvizWidget::PlotTransform(vtkSmartPointer<vtkTransform> transform)
{
	PlotSaveBeforeTransform();
	
	vtkSmartPointer<vtkTransformFilter> transformFilter = vtkSmartPointer<vtkTransformFilter>::New();
#if VTK_MAJOR_VERSION <= 5
	transformFilter->SetInput(plot);
#else
    transformFilter->SetInputData(plot);
#endif
	transformFilter->SetTransform(transform);
	transformFilter->Update();
	
	vtkPointSet* out = transformFilter->GetOutput();
	vtkPoints* points = out->GetPoints();
	
	vtkPoints* plotPoints = plot->GetPoints();
	plotPoints->DeepCopy(points);
	
	refresh();
}

void PvizWidget::PlotRevertToSaved()
{
	qDebug() << "PlotRevertToSaved ... " << savedPoints;
	vtkPoints* plotPoints = plot->GetPoints();	
	plotPoints->DeepCopy(savedPoints);
	savedPointsExist = false;
	refresh();
}

void PvizWidget::PlotSaveBeforeTransform()
{
	qDebug() << "PlotSaveBeforeTransform ... " << savedPoints;
	savedPoints->Reset();
	vtkPoints* plotPoints = plot->GetPoints();	
	savedPoints->DeepCopy(plotPoints);
	savedPointsExist = true;
}

bool PvizWidget::GetSavedPointsExist()
{
	return savedPointsExist;
}

void PvizWidget::ResetCamera()
{
    qDebug() << "ResetCamera ... ";
	double pos[3] = {0.0, 0.0, 0.0};
	double org[3] = {0.0, 0.0, 0.0};
    double radius = 0.0;
    
	axesActor->VisibilityOff();
    renderer->ResetCamera();
    renderer->GetActiveCamera()->GetFocalPoint(pos);
    radius = renderer->GetActiveCamera()->GetDistance();
    switch (focusMode_)
    {
        case AUTO:
            axesActor->SetPosition(pos);
            renderer->GetActiveCamera()->SetPosition(pos[0], pos[1], pos[2] + radius);
            renderer->GetActiveCamera()->SetViewUp(0, 1, 0);
            renderer->ResetCamera();
            break;
        case ORIGIN:
            renderer->GetActiveCamera()->SetFocalPoint(0, 0, 0);
            renderer->GetActiveCamera()->SetPosition(0, 0, (radius + vtkMath::Distance2BetweenPoints(pos, org))*1.5);
            renderer->GetActiveCamera()->SetViewUp(0, 1, 0);
            renderer->Render();
            axesActor->SetPosition(0, 0, 0);
            renderer->ResetCameraClippingRange();
            break;
        case CUSTOM_FOCUS:
            renderer->GetActiveCamera()->SetFocalPoint(focus[0], focus[1], focus[2]);
            renderer->GetActiveCamera()->SetPosition(focus[0], focus[1], focus[2] + (radius + vtkMath::Distance2BetweenPoints(pos, org))*1.5);
            renderer->GetActiveCamera()->SetViewUp(0, 1, 0);
            renderer->Render();
            axesActor->SetPosition(focus[0], focus[1], focus[2]);
            renderer->ResetCameraClippingRange();
            break;
    }
	axesActor->VisibilityOn();
    refresh();    
}

void PvizWidget::PickCenter()
{
    SetInteractorMode(PICKCENTER_MODE);
}

void PvizWidget::SetLookAt(double pos[3])
{
    axesActor->SetPosition(pos);
    renderer->GetActiveCamera()->SetFocalPoint(pos);
    focus[0] = pos[0];
    focus[1] = pos[1];
    focus[2] = pos[2];
    
    refresh();
}

void PvizWidget::SetLabelVisible(bool b)
{
    labelActor->SetVisibility(b);
    
    selectedPointIds->Reset();

    labelVisible = b;
    setHoverTimerActivate(b);

    refresh();
}

bool PvizWidget::GetLabelVisible()
{
    return labelVisible;
}

void PvizWidget::SelectNeighbor()
{
    if (selectedPointIds->GetSize() == 0) return;
        
    colorMap_ = CUSTOM;
    
    qDebug() << "SelectNeighbor ... selected : " << selectedPointIds->GetSize();
    vtkPoints *points = plot->GetPoints();
    double* pos = points->GetPoint(selectedPointIds->GetValue(0));
    
    VTK_CREATE(vtkDoubleArray, dist);
    VTK_CREATE(vtkIdList, ids);
    
    QMap<unsigned int, PvizPoint*> points_(model->points);
    
    //foreach(PvizPoint* point, points_)
    PvizPointMap_t::iterator it;

    double d;
    PvizPoint* point;
    //int tid;
    // i686-apple-darwin10-gcc-4.2.1 (GCC) 4.2.1 makes error
#pragma omp parallel private(it, d, point)
    for (it = model->points.begin(); it != model->points.end(); it++)
    {
        //tid = omp_get_thread_num();
        //qDebug() << "tid" << tid << it->first;
        //PvizPoint* point =  model->points[i];
        point = it->second;
        //PvizPoint* point = pair.second;
        
        d = vtkMath::Distance2BetweenPoints(pos, point->position);
        //qDebug() << point->id << ":" << d;
        
#pragma omp critical 
        {
            ids->InsertNextId(point->id);
            dist->InsertNextValue(d);
        }
    }
    
    vtkSortDataArray::Sort(dist, ids);
    
    /*
    qDebug() << "Sorted ... ";
    for (int i = 0; i < ids->GetNumberOfIds(); i++)
    {
        qDebug() << ids->GetId(i) << dist->GetValue(i);
    }
     */
    
    selectedNeighbors->Reset();
    /*
     int totalNumOfIds = selectedNeighbors->GetNumberOfIds() + numOfNeighbors_;
     if (!appendNeighbors) 
     {
     selectedNeighbors->Reset();
     totalNumOfIds = numOfNeighbors_;
     }
     for (int i = 0; i < selectedNeighbors->GetNumberOfIds(); i++)
     {
     unsigned int cid = selectedNeighbors->GetId(i);
     if (model->clusters[cid]->isDefault)
     {
     selectedNeighbors->DeleteId(i);
     totalNumOfIds--;
     }
     }
     qDebug() << "Currently selected neighbors" << selectedNeighbors->GetNumberOfIds();
     */
    
    //QMap<unsigned int, PvizCluster*> clusters_(model->clusters);
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
    
    for (int i = 0; i < ids->GetNumberOfIds(); i++)
    {
        foreach(PvizCluster* cluster, clusters_)
        {
            if (cluster->hasPoint(points_[ids->GetId(i)]))
            {
                selectedNeighbors->InsertUniqueId(cluster->id);
            }
        }
        if ((selectedNeighbors->GetNumberOfIds() >= (unsigned int) model->clusters.size()) 
            || (selectedNeighbors->GetNumberOfIds() >= numOfNeighbors_)) break;
    }
    
    qDebug() << "Disable all ... ";
    if (!appendNeighbors)
    {
        foreach(PvizCluster* cluster, clusters_)
        {
            unsigned int cid = cluster->id;
            //qDebug() << cid << cluster->isDefault;
            //SetClusterVisible(cluster->id, false);
            
            //SetClusterAsdefault(cid, true);
            
            // Overwrite evertyhing ... 
            // Not sure if this is a right way
            SetClusterColor(cid, GetDefaultColor());
            SetClusterScale(cid, GetDefaultScale());
            cluster->SetAsDefault(true);
        }
    }
    
    qDebug() << "Selected ... " << selectedNeighbors->GetNumberOfIds();
    
    // Preserve old ones
    /*
     for (int i = 0; i < selectedNeighbors->GetNumberOfIds(); i++)
     {
     unsigned int cid = selectedNeighbors->GetId(i);
     }
     */
    {
        int i = 0;
        while (i < selectedNeighbors->GetNumberOfIds()) 
        {
            unsigned int cid = selectedNeighbors->GetId(i);
            if (!model->clusters[cid]->IsDefault())
            {
                selectedNeighbors->DeleteId(cid);
            }
            else
            {
                i++;
            }
        }
    }
    
    int numberOfNonDefaultCluster = model->GetNumberOfNonDefaultCluster();
    qDebug() << "numberOfNonDefaultCluster" << numberOfNonDefaultCluster;
    //for (int i = 0; i < selectedNeighbors->GetNumberOfIds(); i++)
    int ncolor = sizeof(distinct) / sizeof(distinct[0]);
    for (int i = selectedNeighbors->GetNumberOfIds()-1; i >= 0; i--)
    {
        unsigned int cid = selectedNeighbors->GetId(i);
        int j = i + numberOfNonDefaultCluster;
        //qDebug() << cid;
        //SetClusterVisible(cid, true);
        //SetClusterAsdefault(cid, false);
        PvizCluster* cluster = model->clusters[cid];
        cluster->SetAsDefault(false);
        model->ClusterListMoveFront(cluster);        
        SetClusterColor(cid, QColor(distinct[j % ncolor][0]*255,
                                    distinct[j % ncolor][1]*255,
                                    distinct[j % ncolor][2]*255));
        //model->clusters[cid]->SetAsDefault(false);
        //model->ClusterListMoveFront(model->clusters[cid]);
        SetClusterScale(cid, 1.0);
        //model->clusters[cid]->scale = 1.0;
    }
    
    this->update();	

        /*
        qDebug() << "Sorting ...";
        //sortedClusterList.clear();
        for (int i = 0; i < selectedNeighbors->GetNumberOfIds(); i++)
        {
            unsigned int cid = selectedNeighbors->GetId(i);
            PvizCluster* cluster = model->clusters[cid];
            //sortedClusterList.append(cluster);
            //model->moveClusterToHead(cluster);
            model->ClusterListMoveBack(cluster);
        }
         */
        
        /*
        foreach(PvizCluster* cluster, clusters_)
        {
            if (sortedClusterList.indexOf(cluster) == -1)
            {
                sortedClusterList.append(cluster);
            }
        }
        */
    
    //vtkIdType pidx = pids->LookupValue(pid);

    /*
    points->GetPoint(pidx, point->position);
    
    
	vtkPoints *points = plot->GetPoints();
	
	QMap<unsigned int, PvizPoint*> points_(model->points);
	foreach(PvizPoint* point, points_)
	{
		vtkIdType pidx = pids->LookupValue(point->id);		
		points->SetPoint(pidx, point->position);
	}
     */
}

void PvizWidget::SetNumOfNeighbors(int num)
{
    qDebug() << "SetNumOfNeighbors ... " << num;
    numOfNeighbors_ = num;
}

int PvizWidget::GetNumOfNeighbors()
{
    return numOfNeighbors_;
}

void PvizWidget::SetAppendNeighbors(bool b)
{
    appendNeighbors = b;
}

bool PvizWidget::GetAppendNeighbors()
{
    return appendNeighbors;
}

/*
PvizWidget::PvizClusterList_t PvizWidget::GetSortedClusterList()
{
    return sortedClusterList;
}
*/

void PvizWidget::SetDefaultColor(QColor col)
{
    /*
    PvizCluster::DefaultColor.uc_color.r = col.red();
    PvizCluster::DefaultColor.uc_color.g = col.green();
    PvizCluster::DefaultColor.uc_color.b = col.blue();
    PvizCluster::DefaultColor.uc_color.a = col.alpha();
     */
    defaultColor = col;
}

QColor PvizWidget::GetDefaultColor()
{
    return defaultColor;
    //return QColor(PvizCluster::DefaultColor.ui_color);
}

void PvizWidget::SetDefaultScale(double scale)
{
    //PvizCluster::DefaultScale = scale;
    defaultScale = scale;
}

double PvizWidget::GetDefaultScale()
{
    //return PvizCluster::DefaultScale;
    return defaultScale;
}

void PvizWidget::SortClusterBySize(bool descending)
{
    model->SortClusterBySize(descending);
    
}

void PvizWidget::SortClusterById(bool descending)
{
    model->SortClusterById(descending);
    
}

void PvizWidget::SortClusterByLabel(bool descending)
{
    model->SortClusterByLabel(descending);    
}

void PvizWidget::SetFocusMode(FocusMode_t mode)
{
    focusMode_ = mode;
    
    ResetCamera();
}

PvizWidget::FocusMode_t PvizWidget::GetFocusMode()
{
    return focusMode_;
}

QString PvizWidget::GetFileName()
{
    return fileName_;
}

void PvizWidget::SetTitle(QString title)
{
    titleActor->SetInput(title.toAscii().data());
    refresh();
}

QString PvizWidget::GetTitle()
{
    return QString(titleActor->GetInput());
}

void PvizWidget::SetTitleVisible(bool b)
{
    
    if (GetTitle() == "")
    {
        titleActor->SetVisibility(false);
    }
    else
    {
        titleActor->SetVisibility(b);
    }
    
    refresh();
}

bool PvizWidget::GetTitleVisible()
{
    return titleActor->GetVisibility();
}

void PvizWidget::SetTitleColor(QColor col)
{
    titleActor->GetTextProperty()->SetColor(col.redF(), col.greenF(), col.blueF());
    refresh();
}

QColor PvizWidget::GetTitleColor()
{
    double rgba[4];
    titleActor->GetTextProperty()->GetColor (rgba);
    rgba[3] = 1.0;
    
    QColor col;
    col.setRgbF(rgba[0], rgba[1], rgba[2], rgba[3]);
    return col;
}

double PvizWidget::GetCameraFocusX()
{
    return focus[0];
}
double PvizWidget::GetCameraFocusY()
{
    return focus[1];
}
double PvizWidget::GetCameraFocusZ()
{
    return focus[2];
}

void PvizWidget::SetCameraFocusX(double p)
{
    focus[0] = p;
    SetLookAt(focus);
}

void PvizWidget::SetCameraFocusY(double p)
{
    focus[1] = p;
    SetLookAt(focus);
}

void PvizWidget::SetCameraFocusZ(double p)
{
    focus[2] = p;
    SetLookAt(focus);
}


bool PvizWidget::anyClusterHasGlyph2D()
{
    QList<PvizCluster*> clusters_ = QList<PvizCluster*>::fromStdList(model->clusterList);
    
	foreach(PvizCluster* cluster, clusters_)
    {
        if (cluster->shape < 4) 
            return true;
    }
    
    return false;
}

/*
void PvizWidget::SetPickDelta(int delta)
{
    this->interactorStyle->SetDelta(delta);
}

int PvizWidget::GetPickDelta()
{
    return this->interactorStyle->GetDelta();
}
*/

void PvizWidget::addToSelectedPoint(vtkIdType pidx, bool remove)
{
    vtkIdType idx = selectedPointIds->LookupValue(pidx);
    
    if ((idx != -1) && remove)
    {
        selectedPointIds->SetValue(idx, -1);
    }
    else if ((idx == -1) && !remove)
    {
        selectedPointIds->InsertNextValue(pidx);
    }
}

void PvizWidget::focusInEvent ( QFocusEvent * event )
{
    //qDebug() << "focusInEvent ...";
    
    if (labelVisible && !hoverTimer_)
    {
        setHoverTimerActivate(true);
    }
}

void PvizWidget::focusOutEvent ( QFocusEvent * event )
{
    //qDebug() << "focusOutEvent ...";
    
    if (hoverTimer_)
    {
        setHoverTimerActivate(false);
    }
}

void PvizWidget::setHoverTimerActivate(bool b)
{
    //qDebug() << "setHoverTimerActivate :" << b;
    
    if (b)
    {
        this->GetInteractor()->DestroyTimer(hoverTimer_);
        hoverTimer_ = this->GetInteractor()->CreateOneShotTimer(this->hoverTimerDuration_);
    }
    else
    {
        this->GetInteractor()->DestroyTimer(hoverTimer_);
        hoverTimer_ = 0;
    }
}

void PvizWidget::ApplyJitter(double factor)
{
    vtkUnsignedIntArray *pids = vtkUnsignedIntArray::SafeDownCast(plot->GetPointData()->GetArray(POINT_ID_NAME));
    vtkPoints *points = plot->GetPoints();
    
    QMap<unsigned int, PvizPoint*> points_(model->points);
    foreach(PvizPoint* point, points_)
    {
        vtkIdType pidx = pids->LookupValue(point->id);
        
        double p[3];
        points->GetPoint(pidx, p);
        for (int i = 0; i < 3; i++)
            p[i] = point->position[i] + vtkMath::Gaussian(0.0, factor);
        
        points->SetPoint(pidx, p);
    }
    
    refresh();
}
